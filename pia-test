#!/usr/bin/env bash
# PIA VPN Connection Validator
# Run this while connected to verify no leaks

set -uo pipefail

# Colors
if [[ -t 1 ]]; then
  RED=$(tput setaf 1)
  GREEN=$(tput setaf 2)
  YELLOW=$(tput setaf 3)
  BLUE=$(tput setaf 4)
  NC=$(tput sgr0)
else
  RED='' GREEN='' YELLOW='' BLUE='' NC=''
fi

PASS="${GREEN}PASS${NC}"
FAIL="${RED}FAIL${NC}"
WARN="${YELLOW}WARN${NC}"

echo "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
echo "${BLUE}                 PIA VPN Connection Validator                   ${NC}"
echo "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
echo ""

# Track overall status
TESTS_PASSED=0
TESTS_FAILED=0
TESTS_WARNED=0

# --- Test 1: WireGuard Interface ---
echo "${BLUE}[1] WireGuard Interface${NC}"

wg_output=$(sudo wg show 2>/dev/null)
if [[ -z "$wg_output" ]]; then
  echo "    Status:     $FAIL - No WireGuard interface found"
  ((TESTS_FAILED++))
else
  wg_iface=$(echo "$wg_output" | grep "^interface:" | awk '{print $2}')
  echo "    Interface:  ${GREEN}$wg_iface${NC}"

  # Check handshake
  handshake=$(echo "$wg_output" | grep "latest handshake:" | sed 's/.*latest handshake: //')
  if [[ -n "$handshake" ]]; then
    echo "    Handshake:  ${GREEN}$handshake${NC}"
    ((TESTS_PASSED++))
  else
    echo "    Handshake:  $FAIL - No handshake (tunnel may not be working)"
    ((TESTS_FAILED++))
  fi

  # Check transfer
  transfer=$(echo "$wg_output" | grep "transfer:" | sed 's/.*transfer: //')
  if [[ -n "$transfer" ]]; then
    echo "    Transfer:   ${GREEN}$transfer${NC}"
  fi

  # Check endpoint
  endpoint=$(echo "$wg_output" | grep "endpoint:" | awk '{print $2}')
  if [[ -n "$endpoint" ]]; then
    echo "    Endpoint:   ${GREEN}$endpoint${NC}"
  fi

  # Check AllowedIPs captures all traffic
  allowed_ips=$(echo "$wg_output" | grep "allowed ips:" | sed 's/.*allowed ips: //')
  if [[ "$allowed_ips" == *"0.0.0.0/0"* ]] || [[ "$allowed_ips" == *"0.0.0.0/1"* && "$allowed_ips" == *"128.0.0.0/1"* ]]; then
    echo "    AllowedIPs: $PASS - All traffic routed through tunnel"
    ((TESTS_PASSED++))
  else
    echo "    AllowedIPs: $FAIL - Not capturing all traffic: $allowed_ips"
    ((TESTS_FAILED++))
  fi

  # Check handshake age (stale = potential issue)
  if [[ -n "$handshake" ]]; then
    # Parse handshake age
    if [[ "$handshake" == *"minute"* ]]; then
      handshake_mins=$(echo "$handshake" | grep -o '[0-9]*' | head -1)
      if [[ "$handshake_mins" -gt 5 ]]; then
        echo "    Freshness:  $WARN - Last handshake ${handshake_mins}m ago (may be stale)"
        ((TESTS_WARNED++))
      else
        echo "    Freshness:  $PASS - Handshake recent"
        ((TESTS_PASSED++))
      fi
    elif [[ "$handshake" == *"second"* ]]; then
      echo "    Freshness:  $PASS - Handshake very recent"
      ((TESTS_PASSED++))
    elif [[ "$handshake" == *"hour"* ]] || [[ "$handshake" == *"day"* ]]; then
      echo "    Freshness:  $WARN - Handshake stale ($handshake)"
      ((TESTS_WARNED++))
    fi
  fi
fi
echo ""

# --- Test 2: Public IP Check ---
echo "${BLUE}[2] Public IP Check${NC}"

# Get public IP from multiple sources
ip_ipify=$(curl -s --tlsv1.2 --max-time 5 https://api.ipify.org 2>/dev/null)
ip_icanhazip=$(curl -s --tlsv1.2 --max-time 5 https://icanhazip.com 2>/dev/null | tr -d '[:space:]')

if [[ -n "$ip_ipify" ]]; then
  echo "    ipify.org:  ${GREEN}$ip_ipify${NC}"

  # Check if it's a PIA IP (M247/PIA ranges)
  ip_info=$(curl -s --tlsv1.2 --max-time 5 "https://ipinfo.io/$ip_ipify/json" 2>/dev/null)
  if [[ -n "$ip_info" ]]; then
    org=$(echo "$ip_info" | grep -o '"org": *"[^"]*"' | cut -d'"' -f4)
    city=$(echo "$ip_info" | grep -o '"city": *"[^"]*"' | cut -d'"' -f4)
    country=$(echo "$ip_info" | grep -o '"country": *"[^"]*"' | cut -d'"' -f4)
    echo "    Location:   ${GREEN}$city, $country${NC}"
    echo "    ISP:        ${GREEN}$org${NC}"

    # PIA uses various datacenter providers worldwide
    if [[ "$org" == *"M247"* ]] || [[ "$org" == *"PIA"* ]] || [[ "$org" == *"Private Internet Access"* ]] || \
       [[ "$org" == *"Glesys"* ]] || [[ "$org" == *"Privex"* ]] || [[ "$org" == *"Quadranet"* ]] || \
       [[ "$org" == *"Cogent"* ]] || [[ "$org" == *"Leaseweb"* ]] || [[ "$org" == *"Datacamp"* ]]; then
      echo "    VPN IP:     $PASS - Detected as VPN/datacenter IP"
      ((TESTS_PASSED++))
    else
      echo "    VPN IP:     $WARN - ISP not recognized as known PIA provider"
      ((TESTS_WARNED++))
    fi
  fi
else
  echo "    ipify.org:  $FAIL - Could not retrieve public IP"
  ((TESTS_FAILED++))
fi

if [[ -n "$ip_icanhazip" && "$ip_icanhazip" != "$ip_ipify" ]]; then
  echo "    icanhazip:  ${YELLOW}$ip_icanhazip${NC} (differs from ipify!)"
  ((TESTS_WARNED++))
fi
echo ""

# --- Test 3: DNS Leak Test ---
echo "${BLUE}[3] DNS Leak Test${NC}"

# Get PIA DNS from WireGuard config (dynamic, not hardcoded)
pia_dns=""
if [[ -f /etc/wireguard/pia.conf ]]; then
  pia_dns=$(grep "^DNS" /etc/wireguard/pia.conf 2>/dev/null | cut -d= -f2 | tr -d ' ')
fi
# Fallback: check system DNS for 10.0.0.x (PIA's unfortunate choice)
if [[ -z "$pia_dns" ]]; then
  pia_dns=$(scutil --dns 2>/dev/null | grep "nameserver\[" | awk '{print $3}' | grep "^10\.0\.0\." | head -1)
fi
# Last resort: try common PIA DNS IPs
if [[ -z "$pia_dns" ]]; then
  for try_dns in 10.0.0.243 10.0.0.242 10.0.0.241; do
    if nslookup -timeout=1 google.com "$try_dns" >/dev/null 2>&1; then
      pia_dns="$try_dns"
      break
    fi
  done
fi

# Check configured DNS
dns_servers=$(scutil --dns 2>/dev/null | grep "nameserver\[" | head -5 | awk '{print $3}' | sort -u | tr '\n' ' ')
echo "    Configured: ${GREEN}${dns_servers:-None}${NC}"

if [[ -z "$pia_dns" ]]; then
  echo "    PIA DNS:    $WARN - Could not detect PIA DNS server"
  ((TESTS_WARNED++))
else
  echo "    PIA DNS:    ${GREEN}$pia_dns${NC}"

  # Test DNS resolution through PIA DNS (nslookup)
  dns_test=$(nslookup -timeout=3 google.com "$pia_dns" 2>/dev/null)
  if [[ $? -eq 0 ]]; then
    echo "    nslookup:   $PASS - Resolving through PIA DNS"
    ((TESTS_PASSED++))
  else
    echo "    nslookup:   $FAIL - Cannot resolve through PIA DNS"
    ((TESTS_FAILED++))
  fi

  # Test with dig if available (different code path)
  if command -v dig >/dev/null 2>&1; then
    dig_test=$(dig +short +time=3 "@$pia_dns" google.com 2>/dev/null)
    if [[ -n "$dig_test" ]]; then
      echo "    dig:        $PASS - Resolving through PIA DNS"
      ((TESTS_PASSED++))
    else
      echo "    dig:        $FAIL - Cannot resolve through PIA DNS"
      ((TESTS_FAILED++))
    fi
  fi

  # Test with host if available (yet another code path)
  if command -v host >/dev/null 2>&1; then
    host_test=$(host -W 3 google.com "$pia_dns" 2>/dev/null)
    if [[ $? -eq 0 ]]; then
      echo "    host:       $PASS - Resolving through PIA DNS"
      ((TESTS_PASSED++))
    else
      echo "    host:       $FAIL - Cannot resolve through PIA DNS"
      ((TESTS_FAILED++))
    fi
  fi

  # Check if DNS route is through tunnel (only for 10.x.x.x addresses)
  if [[ "$pia_dns" == 10.* ]]; then
    dns_route=$(netstat -rn 2>/dev/null | grep "^$pia_dns")
    if [[ "$dns_route" == *"utun"* ]]; then
      echo "    DNS Route:  $PASS - Routed through VPN tunnel"
      ((TESTS_PASSED++))
    else
      echo "    DNS Route:  $WARN - May route locally (PIA uses 10.0.0.x which conflicts with common LANs)"
      ((TESTS_WARNED++))
    fi
  fi
fi
echo ""

# --- Test 4: Route Table Check ---
echo "${BLUE}[4] Route Table Check${NC}"

# Check for VPN routes
route_0=$(netstat -rn 2>/dev/null | grep "^0/1.*utun")
route_128=$(netstat -rn 2>/dev/null | grep "^128.0/1.*utun")

if [[ -n "$route_0" && -n "$route_128" ]]; then
  echo "    0.0.0.0/1:  $PASS - Routed through VPN"
  echo "    128.0.0.0/1: $PASS - Routed through VPN"
  ((TESTS_PASSED++))
else
  echo "    VPN Routes: $FAIL - Default routes not through VPN"
  ((TESTS_FAILED++))
fi

# Check bypass route exists (for WG endpoint)
bypass_route=$(netstat -rn 2>/dev/null | grep "91.90.126" | head -1)
if [[ -n "$bypass_route" ]]; then
  bypass_gw=$(echo "$bypass_route" | awk '{print $2}')
  echo "    Bypass:     $PASS - WG endpoint via $bypass_gw"
  ((TESTS_PASSED++))
fi
echo ""

# --- Test 5: Traffic Test ---
echo "${BLUE}[5] Traffic Test${NC}"

# Ping test through tunnel
ping_result=$(ping -c 3 -W 2 1.1.1.1 2>/dev/null)
if [[ $? -eq 0 ]]; then
  ping_time=$(echo "$ping_result" | grep "avg" | awk -F'/' '{print $5}')
  echo "    Ping 1.1.1.1: $PASS - ${ping_time}ms avg"
  ((TESTS_PASSED++))
else
  echo "    Ping 1.1.1.1: $FAIL - No response"
  ((TESTS_FAILED++))
fi

# HTTP test
http_test=$(curl -s --tlsv1.2 --max-time 5 -o /dev/null -w "%{http_code}" https://www.google.com 2>/dev/null)
if [[ "$http_test" =~ ^[23] ]]; then
  echo "    HTTPS:      $PASS - Google responded $http_test"
  ((TESTS_PASSED++))
else
  echo "    HTTPS:      $FAIL - HTTP code: $http_test"
  ((TESTS_FAILED++))
fi

# MTU test - verify tunnel can handle typical payloads
# WireGuard MTU is typically 1420, so 1372 data + 28 header = 1400 should work
mtu_test=$(ping -c 1 -W 3 -D -s 1372 1.1.1.1 2>/dev/null)
if [[ $? -eq 0 ]]; then
  echo "    MTU (1400): $PASS - Large packets work through tunnel"
  ((TESTS_PASSED++))
else
  echo "    MTU (1400): $WARN - Tunnel MTU may be reduced"
  ((TESTS_WARNED++))
fi
echo ""

# --- Test 6: Kill Switch / Firewall ---
echo "${BLUE}[6] Kill Switch${NC}"

# Check pf firewall status (macOS)
if [[ "$(uname)" == "Darwin" ]]; then
  pf_enabled=$(sudo pfctl -s info 2>/dev/null | grep "Status:" | awk '{print $2}')

  if [[ "$pf_enabled" == "Enabled" ]]; then
    echo "    pf status:  ${GREEN}Enabled${NC}"

    # Check specifically for PIA kill switch anchor
    pia_ks_rules=$(sudo pfctl -a pia_killswitch -s rules 2>/dev/null | wc -l | tr -d ' ')
    if [[ "$pia_ks_rules" -gt 0 ]]; then
      # Get some details about the rules
      block_rules=$(sudo pfctl -a pia_killswitch -s rules 2>/dev/null | grep -c "block")
      pass_rules=$(sudo pfctl -a pia_killswitch -s rules 2>/dev/null | grep -c "pass")
      echo "    Kill switch: $PASS - Active ($block_rules block, $pass_rules pass rules)"
      ((TESTS_PASSED++))

      # Check IPv6 blocking
      ipv6_blocked=$(sudo pfctl -a pia_killswitch -s rules 2>/dev/null | grep -c "block.*inet6")
      if [[ "$ipv6_blocked" -gt 0 ]]; then
        echo "    IPv6 block: $PASS - IPv6 blocked at firewall"
        ((TESTS_PASSED++))
      else
        echo "    IPv6 block: $WARN - IPv6 not blocked by kill switch"
        ((TESTS_WARNED++))
      fi

      # Show what's allowed
      lan_allowed=$(sudo pfctl -a pia_killswitch -s rules 2>/dev/null | grep "pass" | grep -v "lo0\|utun\|loopback" | head -1)
      if [[ -n "$lan_allowed" ]]; then
        lan_subnet=$(echo "$lan_allowed" | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]+' | head -1)
        if [[ -n "$lan_subnet" ]]; then
          echo "    LAN allowed: ${GREEN}$lan_subnet${NC}"
        fi
      fi
    else
      # Check for any other block rules
      other_blocks=$(sudo pfctl -s rules 2>/dev/null | grep -c "block")
      if [[ "$other_blocks" -gt 0 ]]; then
        echo "    Kill switch: $WARN - pf has blocks but PIA kill switch not active"
        ((TESTS_WARNED++))
      else
        echo "    Kill switch: $WARN - Not active (traffic may leak if VPN drops)"
        ((TESTS_WARNED++))
      fi
    fi
  else
    echo "    pf status:  ${YELLOW}Disabled${NC}"
    echo "    Kill switch: $WARN - Not active (traffic may leak if VPN drops)"
    ((TESTS_WARNED++))
  fi
else
  # Linux - check iptables
  if command -v iptables >/dev/null 2>&1; then
    ipt_rules=$(sudo iptables -L -n 2>/dev/null | grep -c "DROP\|REJECT")
    if [[ "$ipt_rules" -gt 0 ]]; then
      echo "    iptables:   $PASS - $ipt_rules drop/reject rules found"
      ((TESTS_PASSED++))
    else
      echo "    iptables:   $WARN - No kill switch rules detected"
      ((TESTS_WARNED++))
    fi
  fi
fi
echo ""

# --- Test 7: Potential Leak Sources ---
echo "${BLUE}[7] Potential Leak Sources${NC}"

# Check for IPv6 on ALL network interfaces
ipv6_leaks=""
while IFS= read -r service; do
  [[ -z "$service" ]] && continue
  ipv6_status=$(networksetup -getinfo "$service" 2>/dev/null | grep "IPv6:" | awk '{print $2}')
  if [[ "$ipv6_status" == "Automatic" || "$ipv6_status" == "Manual" ]]; then
    ipv6_leaks="$ipv6_leaks $service"
  fi
done < <(networksetup -listallnetworkservices 2>/dev/null | tail -n +2)

if [[ -n "$ipv6_leaks" ]]; then
  echo "    IPv6:       $WARN - Enabled on:$ipv6_leaks"
  ((TESTS_WARNED++))
else
  echo "    IPv6:       $PASS - Disabled on all interfaces"
  ((TESTS_PASSED++))
fi

# Check for known leak processes
leak_procs=""
for proc in "AnyDesk" "TeamViewer" "Chrome Remote Desktop"; do
  if pgrep -i "$proc" >/dev/null 2>&1; then
    leak_procs="$leak_procs $proc"
  fi
done

if [[ -n "$leak_procs" ]]; then
  echo "    Remote:     $WARN - Found:$leak_procs"
  ((TESTS_WARNED++))
else
  echo "    Remote:     $PASS - No remote access tools detected"
  ((TESTS_PASSED++))
fi

# WebRTC - browser-level leak, cannot reliably test from CLI
# NOTE: WebRTC leaks occur inside browsers, not at system/network level.
# Each browser has different settings and users may intentionally use
# different browsers for VPN vs non-VPN activities.
# TODO: Future option - headless browser test with puppeteer/playwright
echo "    WebRTC:     ${YELLOW}Manual check required${NC} - browserleaks.com/webrtc"
echo ""

# --- Test 8: Port Forwarding (optional feature) ---
echo "${BLUE}[8] Port Forwarding${NC}"

# Port forwarding is optional - only some regions support it, and it's not
# required for VPN security. This section is informational only.
pf_pid=$(pgrep -f "port_forwarding.sh" 2>/dev/null)
if [[ -n "$pf_pid" ]]; then
  echo "    Status:     ${GREEN}Active${NC} (PID: $pf_pid)"
  ((TESTS_PASSED++))

  # Try to find the forwarded port
  if [[ -f /opt/piavpn-manual/debug_info ]]; then
    pf_port=$(grep -o "port is [0-9]*" /opt/piavpn-manual/debug_info 2>/dev/null | tail -1 | awk '{print $3}')
    if [[ -n "$pf_port" ]]; then
      echo "    Port:       ${GREEN}$pf_port${NC}"
    fi
  fi
else
  echo "    Status:     ${YELLOW}Not active${NC} (optional feature)"
fi
echo ""

# --- Test 9: Reconnection Info ---
echo "${BLUE}[9] Reconnection${NC}"

# This section is informational - connection health is verified in Test 1.
# Show how the user can reconnect if the VPN drops.
# Config may be in /etc/wireguard/ (Linux default) or /usr/local/etc/wireguard/ (macOS Homebrew)
# Directory is mode 700, so we need to check with elevated permissions

wg_config_found=false
for config_path in /etc/wireguard/pia.conf /usr/local/etc/wireguard/pia.conf; do
  if sudo test -f "$config_path" 2>/dev/null; then
    echo "    Quick:      ${GREEN}wg-quick up pia${NC}"
    echo "    Config:     ${GREEN}$config_path${NC}"

    # Show config age (indicates key age)
    config_mtime=$(sudo stat -f "%m" "$config_path" 2>/dev/null || sudo stat -c "%Y" "$config_path" 2>/dev/null)
    if [[ -n "$config_mtime" ]]; then
      now=$(date +%s)
      age_hours=$(( (now - config_mtime) / 3600 ))
      age_days=$(( age_hours / 24 ))
      if [[ "$age_days" -gt 30 ]]; then
        echo "    Key age:    $WARN - Config is ${age_days} days old (consider rotating)"
        ((TESTS_WARNED++))
      elif [[ "$age_days" -gt 0 ]]; then
        echo "    Key age:    ${GREEN}${age_days} days${NC}"
      else
        echo "    Key age:    ${GREEN}${age_hours} hours${NC}"
      fi
    fi

    wg_config_found=true
    ((TESTS_PASSED++))
    break
  fi
done

if [[ "$wg_config_found" == "false" ]]; then
  echo "    Method:     ${YELLOW}./run_setup.sh${NC} (no saved config for wg-quick)"
fi
echo ""

# --- Summary ---
echo "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
echo "${BLUE}                          SUMMARY                               ${NC}"
echo "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
echo ""
echo "    ${GREEN}PASSED:${NC}  $TESTS_PASSED"
echo "    ${YELLOW}WARNED:${NC}  $TESTS_WARNED"
echo "    ${RED}FAILED:${NC}  $TESTS_FAILED"
echo ""

if [[ $TESTS_FAILED -eq 0 && $TESTS_WARNED -eq 0 ]]; then
  echo "    ${GREEN}VPN connection appears secure.${NC}"
elif [[ $TESTS_FAILED -eq 0 ]]; then
  echo "    ${YELLOW}VPN connected with warnings - review above.${NC}"
else
  echo "    ${RED}VPN connection has issues - review failures above.${NC}"
fi
echo ""
