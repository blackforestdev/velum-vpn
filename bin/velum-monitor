#!/usr/bin/env bash
# velum-monitor - Background VPN health monitoring daemon
# Monitors VPN connection, kill switch, and sends desktop notifications

set -euo pipefail

# ============================================================================
# INITIALIZATION
# ============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VELUM_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
export VELUM_ROOT

# Source libraries
source "$VELUM_ROOT/lib/velum-core.sh"
source "$VELUM_ROOT/lib/os/detect.sh"

# Monitor configuration
MONITOR_INTERVAL="${VELUM_MONITOR_INTERVAL:-10}"  # Check every 10 seconds
HANDSHAKE_STALE_THRESHOLD=180  # 3 minutes without handshake = stale
PID_FILE="/tmp/velum-monitor.pid"
STATE_FILE="/tmp/velum-monitor.state"

# State tracking
LAST_VPN_STATE="unknown"
LAST_KS_STATE="unknown"
LAST_HANDSHAKE_ALERT=0
LAST_VPN_ALERT=0
LAST_KS_ALERT=0
NOTIFICATION_DEBOUNCE=5  # Minimum seconds between same notification type

# ============================================================================
# NOTIFICATIONS (Cross-platform)
# ============================================================================

# Get console user for running commands as logged-in user
_get_notify_user() {
  # Check VELUM_NOTIFY_USER (passed from parent process)
  if [[ -n "${VELUM_NOTIFY_USER:-}" ]]; then
    echo "$VELUM_NOTIFY_USER"
    return 0
  fi

  # Check SUDO_USER
  if [[ -n "${SUDO_USER:-}" ]]; then
    echo "$SUDO_USER"
    return 0
  fi

  # Get owner of /dev/console (OS-specific stat syntax)
  local console_user
  if [[ "$VELUM_OS" == "macos" ]]; then
    console_user=$(stat -f "%Su" /dev/console 2>/dev/null)
  else
    # Linux: try /dev/tty1 or pts/0 since /dev/console is root-owned
    console_user=$(who 2>/dev/null | head -1 | awk '{print $1}')
  fi
  if [[ -n "$console_user" && "$console_user" != "root" ]]; then
    echo "$console_user"
    return 0
  fi

  return 1
}

# Send desktop notification with optional sound and speech
# Usage: notify "Title" "Message" "urgency" ["speech_text"]
# Urgency: low, normal, critical
notify() {
  local title="$1"
  local message="$2"
  local urgency="${3:-normal}"
  local speech="${4:-}"  # Optional speech text

  # Log the notification
  log_info "NOTIFY [$urgency]: $title - $message"

  if [[ "$VELUM_OS" == "macos" ]]; then
    local notify_user
    notify_user=$(_get_notify_user)

    # Determine sound based on urgency
    local sound=""
    [[ "$urgency" == "critical" ]] && sound="Basso"
    [[ "$urgency" == "normal" ]] && sound="Blow"

    # Send visual notification using os_notify from macos.sh
    os_notify "$title" "$message" "$sound"

    # Speech synthesis for important alerts
    if [[ -n "$speech" && -n "$notify_user" ]]; then
      # Use different voices/rates for urgency
      if [[ "$urgency" == "critical" ]]; then
        sudo -u "$notify_user" say -v "Samantha" -r 200 "$speech" 2>/dev/null &
      else
        sudo -u "$notify_user" say -v "Samantha" -r 180 "$speech" 2>/dev/null &
      fi
    fi

  else
    # Linux: use notify-send
    local urgency_flag=""
    case "$urgency" in
      low) urgency_flag="-u low" ;;
      critical) urgency_flag="-u critical" ;;
      *) urgency_flag="-u normal" ;;
    esac

    if command -v notify-send >/dev/null 2>&1; then
      local notify_user
      notify_user=$(_get_notify_user)
      if [[ $EUID -eq 0 && -n "$notify_user" ]]; then
        sudo -u "$notify_user" DISPLAY=:0 DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$(id -u "$notify_user")/bus" \
          notify-send $urgency_flag "$title" "$message" 2>/dev/null || true
      else
        notify-send $urgency_flag "$title" "$message" 2>/dev/null || true
      fi
    fi

    # Audio alert for critical (using paplay or aplay if available)
    if [[ "$urgency" == "critical" ]]; then
      if command -v paplay >/dev/null 2>&1; then
        paplay /usr/share/sounds/freedesktop/stereo/alarm-clock-elapsed.oga 2>/dev/null &
      elif command -v aplay >/dev/null 2>&1; then
        aplay /usr/share/sounds/alsa/Front_Center.wav 2>/dev/null &
      fi
    fi

    # Speech synthesis for Linux (using espeak or spd-say)
    if [[ -n "$speech" ]]; then
      if command -v spd-say >/dev/null 2>&1; then
        spd-say "$speech" 2>/dev/null &
      elif command -v espeak >/dev/null 2>&1; then
        espeak "$speech" 2>/dev/null &
      fi
    fi
  fi
}

# ============================================================================
# HEALTH CHECKS
# ============================================================================

# Check if WireGuard VPN interface is up
# Uses 'wg show interfaces' to detect active WireGuard interfaces specifically
# (not just any utun, which could be iCloud Private Relay, etc.)
# Note: daemon runs as root, so no sudo needed
check_vpn_interface() {
  local wg_ifaces
  wg_ifaces=$(wg show interfaces 2>/dev/null || echo "")
  [[ -n "$wg_ifaces" ]]
}

# Get handshake age in seconds
# Note: daemon runs as root, so no sudo needed
get_handshake_age() {
  local wg_output
  wg_output=$(wg show 2>/dev/null || echo "")

  if [[ -z "$wg_output" ]]; then
    echo "999999"
    return
  fi

  local handshake_line
  handshake_line=$(echo "$wg_output" | grep "latest handshake:" || echo "")

  if [[ -z "$handshake_line" ]]; then
    echo "999999"
    return
  fi

  # Parse handshake time (e.g., "1 minute, 30 seconds ago" or "45 seconds ago")
  local total_seconds=0

  if [[ "$handshake_line" =~ ([0-9]+)\ hour ]]; then
    total_seconds=$((total_seconds + BASH_REMATCH[1] * 3600))
  fi
  if [[ "$handshake_line" =~ ([0-9]+)\ minute ]]; then
    total_seconds=$((total_seconds + BASH_REMATCH[1] * 60))
  fi
  if [[ "$handshake_line" =~ ([0-9]+)\ second ]]; then
    total_seconds=$((total_seconds + BASH_REMATCH[1]))
  fi

  echo "$total_seconds"
}

# Check if kill switch is active
# Note: daemon runs as root, so no sudo needed
check_kill_switch() {
  if [[ "$VELUM_OS" == "macos" ]]; then
    # Check pf anchor
    if pfctl -a velum_killswitch -s rules 2>/dev/null | grep -q "block"; then
      return 0
    fi
  else
    # Linux: check nftables first (preferred), then iptables
    # nftables uses "policy drop" or explicit "drop" rules
    if nft list table inet velum_killswitch 2>/dev/null | grep -qi "drop\|reject"; then
      return 0
    fi
    # Fallback to iptables
    if iptables -L VELUM_KILLSWITCH 2>/dev/null | grep -qi "DROP\|REJECT"; then
      return 0
    fi
  fi
  return 1
}

# ============================================================================
# MONITORING LOOP
# ============================================================================

monitor_loop() {
  log_info "VPN monitor started (PID: $$, interval: ${MONITOR_INTERVAL}s)"

  # Save PID (world-readable for status checks)
  echo $$ > "$PID_FILE"
  chmod 644 "$PID_FILE" 2>/dev/null || true

  # Initialize state (world-readable)
  echo "started=$(date +%s)" > "$STATE_FILE"
  chmod 644 "$STATE_FILE" 2>/dev/null || true

  # Notify user that monitoring has started
  notify "VPN Monitor Active" "Background monitoring started. You'll be alerted if VPN drops." "low"

  while true; do
    local vpn_up=false
    local ks_active=false
    local handshake_age=999999
    local now
    now=$(date +%s)

    # Check VPN interface
    if check_vpn_interface; then
      vpn_up=true
      handshake_age=$(get_handshake_age)
    fi

    # Check kill switch
    if check_kill_switch; then
      ks_active=true
    fi

    # Update state file (world-readable for status checks)
    cat > "$STATE_FILE" << EOF
started=$(grep "started=" "$STATE_FILE" 2>/dev/null | cut -d= -f2 || echo "$now")
last_check=$now
vpn_up=$vpn_up
ks_active=$ks_active
handshake_age=$handshake_age
EOF
    chmod 644 "$STATE_FILE" 2>/dev/null || true

    # Alert on VPN state change (with debounce)
    if [[ "$vpn_up" == "true" && "$LAST_VPN_STATE" == "false" ]]; then
      if [[ $((now - LAST_VPN_ALERT)) -gt "$NOTIFICATION_DEBOUNCE" ]]; then
        notify "VPN Connected" "VPN connection restored" "normal" "VPN connection restored"
        log_info "VPN connection restored"
        LAST_VPN_ALERT=$now
      fi
    elif [[ "$vpn_up" == "false" && "$LAST_VPN_STATE" == "true" ]]; then
      # Check if this was an intentional disconnect
      if [[ ! -f "/tmp/velum-intentional-disconnect" ]]; then
        if [[ $((now - LAST_VPN_ALERT)) -gt "$NOTIFICATION_DEBOUNCE" ]]; then
          notify "VPN Disconnected" "VPN connection lost! Kill switch is blocking traffic." "critical" "Warning: VPN connection lost"
          log_warn "VPN connection lost"
          LAST_VPN_ALERT=$now
        fi
      else
        log_info "VPN disconnected intentionally"
      fi
    fi

    # Alert on kill switch state change (with debounce)
    # Only speak kill switch alerts if VPN state didn't also change this cycle
    # (If VPN went down, kill switch disabling is expected - don't double-speak)
    local vpn_changed=false
    [[ "$vpn_up" != "$LAST_VPN_STATE" && "$LAST_VPN_STATE" != "unknown" ]] && vpn_changed=true

    if [[ "$ks_active" == "false" && "$LAST_KS_STATE" == "true" ]]; then
      if [[ $((now - LAST_KS_ALERT)) -gt "$NOTIFICATION_DEBOUNCE" ]]; then
        if [[ "$vpn_up" == "true" ]]; then
          # Kill switch disabled while VPN still up - this is bad!
          notify "Kill Switch Disabled" "Kill switch was disabled while VPN is active!" "critical" "Warning: Kill switch disabled"
        else
          # Kill switch disabled because VPN went down - expected, visual only
          notify "Kill Switch Disabled" "Kill switch disabled." "normal"
        fi
        log_warn "Kill switch disabled unexpectedly"
        LAST_KS_ALERT=$now
      fi
    elif [[ "$ks_active" == "true" && "$LAST_KS_STATE" == "false" ]]; then
      if [[ $((now - LAST_KS_ALERT)) -gt "$NOTIFICATION_DEBOUNCE" ]]; then
        if [[ "$vpn_changed" == "true" ]]; then
          # VPN just reconnected and kill switch came up - visual only, VPN notification has speech
          notify "Kill Switch Enabled" "Kill switch protection restored" "normal"
        else
          # Kill switch restored independently - speak it
          notify "Kill Switch Enabled" "Kill switch protection restored" "normal" "Kill switch restored"
        fi
        log_info "Kill switch restored"
        LAST_KS_ALERT=$now
      fi
    fi

    # Alert on stale handshake (connection degraded)
    if [[ "$vpn_up" == "true" && "$handshake_age" -gt "$HANDSHAKE_STALE_THRESHOLD" ]]; then
      # Only alert once per stale period
      if [[ $((now - LAST_HANDSHAKE_ALERT)) -gt 300 ]]; then
        notify "VPN Connection Stale" "No handshake for ${handshake_age}s. Connection may be degraded." "normal"
        log_warn "Handshake stale: ${handshake_age}s"
        LAST_HANDSHAKE_ALERT=$now
      fi
    fi

    # Update last states
    LAST_VPN_STATE="$vpn_up"
    LAST_KS_STATE="$ks_active"

    sleep "$MONITOR_INTERVAL"
  done
}

# ============================================================================
# COMMANDS
# ============================================================================

cmd_start() {
  # Require root for monitoring (needs wg show, pfctl access)
  if [[ $EUID -ne 0 ]]; then
    echo "Monitor requires root privileges. Run: sudo velum monitor start"
    return 1
  fi

  # Kill any existing monitor daemons (prevents orphaned processes)
  local existing_pids
  existing_pids=$(pgrep -f "velum-monitor daemon" 2>/dev/null || true)
  if [[ -n "$existing_pids" ]]; then
    echo "Cleaning up existing monitor processes..."
    pkill -9 -f "velum-monitor daemon" 2>/dev/null || true
    sleep 0.5
    rm -f "$PID_FILE" "$STATE_FILE"
  fi

  echo "Starting VPN monitor..."

  # Start daemon in background (already running as root)
  # Pass the original user for notifications
  local log_file="/tmp/velum-monitor.log"

  # Clear old log on fresh start
  : > "$log_file"
  local orig_user="${SUDO_USER:-$USER}"
  VELUM_NOTIFY_USER="$orig_user" nohup "$0" daemon >> "$log_file" 2>&1 &
  disown 2>/dev/null || true

  sleep 1

  if [[ -f "$PID_FILE" ]]; then
    local pid
    pid=$(cat "$PID_FILE")
    echo "Monitor started (PID: $pid)"
  else
    echo "Failed to start monitor"
    return 1
  fi
}

cmd_stop() {
  # Kill all monitor daemons (not just the one in PID file)
  local existing_pids
  existing_pids=$(pgrep -f "velum-monitor daemon" 2>/dev/null || true)

  if [[ -n "$existing_pids" ]]; then
    echo "Stopping monitor processes..."
    pkill -9 -f "velum-monitor daemon" 2>/dev/null || true
    rm -f "$PID_FILE" "$STATE_FILE"
    echo "Monitor stopped"
  else
    echo "Monitor not running"
    rm -f "$PID_FILE" "$STATE_FILE"
  fi
}

cmd_status() {
  echo
  echo "${C_BOLD}velum-monitor${C_RESET} - VPN Health Monitor"
  echo "========================================"
  echo

  # Check if running (use ps instead of kill -0 to work without root)
  if [[ -f "$PID_FILE" ]]; then
    local pid
    pid=$(cat "$PID_FILE")
    if ps -p "$pid" >/dev/null 2>&1; then
      echo "Status:       ${C_GREEN}Running${C_RESET} (PID: $pid)"

      # Show state info (may need sudo to read state file)
      if [[ -f "$STATE_FILE" ]] && [[ -r "$STATE_FILE" ]]; then
        source "$STATE_FILE"
        local now
        now=$(date +%s)
        local uptime=$((now - started))
        local uptime_min=$((uptime / 60))

        echo "Uptime:       ${uptime_min} minutes"
        echo "Last check:   $((now - last_check))s ago"
        echo
        echo "VPN:          $([ "$vpn_up" == "true" ] && echo "${C_GREEN}Connected${C_RESET}" || echo "${C_RED}Disconnected${C_RESET}")"
        echo "Kill switch:  $([ "$ks_active" == "true" ] && echo "${C_GREEN}Active${C_RESET}" || echo "${C_RED}Inactive${C_RESET}")"
        if [[ "$vpn_up" == "true" ]]; then
          echo "Handshake:    ${handshake_age}s ago"
        fi
      fi
    else
      echo "Status:       ${C_YELLOW}Stale PID${C_RESET} (process not running)"
    fi
  else
    echo "Status:       ${C_YELLOW}Not running${C_RESET}"
  fi
  echo
  echo "Commands:"
  echo "  velum monitor start   Start background monitoring"
  echo "  velum monitor stop    Stop monitoring"
  echo "  velum monitor status  Show this status"
  echo
  echo "Logs: /tmp/velum-monitor.log"
  if [[ "$VELUM_OS" == "macos" ]]; then
    echo "Tip:  Enable Terminal in System Settings â†’ Notifications for desktop alerts"
  fi
  echo
}

cmd_daemon() {
  # This runs the actual monitoring loop
  # Called internally by cmd_start
  monitor_loop
}

usage() {
  cat << EOF
velum-monitor - VPN Health Monitoring Daemon

Usage: velum monitor <command>

Commands:
  start     Start background monitoring
  stop      Stop monitoring
  status    Show monitor status

Environment:
  VELUM_MONITOR_INTERVAL  Check interval in seconds (default: 10)

The monitor checks:
  - VPN interface status
  - Kill switch rules
  - Handshake freshness

Alerts via desktop notifications when:
  - VPN disconnects
  - Kill switch disabled unexpectedly
  - Connection becomes stale (no handshake)

EOF
}

# ============================================================================
# MAIN
# ============================================================================

main() {
  local cmd="${1:-status}"

  case "$cmd" in
    start)
      cmd_start
      ;;
    stop)
      cmd_stop
      ;;
    status)
      cmd_status
      ;;
    daemon)
      # Internal: run monitoring loop
      cmd_daemon
      ;;
    -h|--help|help)
      usage
      ;;
    *)
      echo "Unknown command: $cmd" >&2
      usage
      exit 1
      ;;
  esac
}

main "$@"
