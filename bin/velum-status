#!/usr/bin/env bash
# velum-status - Show VPN connection status
# Displays: connection state, security status, network info

set -euo pipefail

# ============================================================================
# INITIALIZATION
# ============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VELUM_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
export VELUM_ROOT

# Source libraries
source "$VELUM_ROOT/lib/velum-core.sh"
source "$VELUM_ROOT/lib/velum-security.sh"
source "$VELUM_ROOT/lib/os/detect.sh"

# Configuration
declare -A CONFIG
CONFIG_FILE="$VELUM_CONFIG_FILE"

# Load configuration to get provider (strict parsing - fail fast on malformed config)
load_status_config() {
  if [[ -f "$CONFIG_FILE" ]]; then
    if ! safe_load_config "$CONFIG_FILE" --strict --known-keys-only; then
      print_error "Failed to parse configuration file."
      print_error "Run 'velum config lint' to diagnose issues."
      exit 1
    fi
  fi
}

# Get provider-specific token file
get_token_file() {
  case "${CONFIG[provider]:-}" in
    mullvad) echo "${VELUM_TOKENS_DIR}/mullvad_token" ;;
    ivpn) echo "${VELUM_TOKENS_DIR}/ivpn_token" ;;
    *) echo "$VELUM_TOKEN_FILE" ;;
  esac
}

# ============================================================================
# STATUS CHECKS
# ============================================================================

# Check if WireGuard is running
# Sets global vars: WG_STATUS, WG_IFACE
check_wireguard() {
  WG_IFACE=$(os_detect_vpn_interface 2>/dev/null || echo "")

  if [[ -n "$WG_IFACE" ]]; then
    WG_STATUS="connected"
  else
    WG_STATUS="disconnected"
  fi
}

# Get public IP
get_public_ip() {
  curl -s --tlsv1.2 -m 5 "https://api.ipify.org" 2>/dev/null || echo "unknown"
}

# Get VPN endpoint from WireGuard config
get_vpn_endpoint() {
  if [[ -f /etc/wireguard/velum.conf ]]; then
    grep "^Endpoint" /etc/wireguard/velum.conf 2>/dev/null | awk -F'= ' '{print $2}' | cut -d: -f1
  fi
}

# Check if IP matches VPN server
check_ip_match() {
  local public_ip="$1"
  local vpn_server="$2"

  # For PIA, the public IP should be on the same /24 as the server
  # This is a heuristic - actual IP will differ
  if [[ -n "$vpn_server" && -n "$public_ip" && "$public_ip" != "unknown" ]]; then
    local pub_prefix="${public_ip%.*}"
    local vpn_prefix="${vpn_server%.*}"

    # Check if in same rough network (not exact, but indicative)
    # In practice, just checking we're not our original IP is enough
    [[ "$public_ip" != "$(os_get_local_ip 2>/dev/null || echo '')" ]]
  else
    return 1
  fi
}

# ============================================================================
# DISPLAY
# ============================================================================

show_status() {
  echo
  echo "${C_BOLD}velum-vpn Status${C_RESET}"
  echo "================"
  echo

  # WireGuard status
  check_wireguard

  echo "Connection:"
  # Show provider if configured
  if [[ -n "${CONFIG[provider]:-}" ]]; then
    local provider_display="${CONFIG[provider]^^}"
    echo "  Provider:     ${C_BOLD}$provider_display${C_RESET}"
  fi

  if [[ "$WG_STATUS" == "connected" ]]; then
    echo "  Status:       ${C_GREEN}CONNECTED${C_RESET}"
    echo "  Interface:    $WG_IFACE"

    # Get endpoint
    local endpoint
    endpoint=$(get_vpn_endpoint)
    [[ -n "$endpoint" ]] && echo "  VPN Server:   $endpoint"

    # Get public IP
    echo -n "  Public IP:    "
    local public_ip
    public_ip=$(get_public_ip)
    if [[ "$public_ip" != "unknown" ]]; then
      echo "${C_GREEN}$public_ip${C_RESET}"
    else
      echo "${C_YELLOW}Could not determine${C_RESET}"
    fi

    # WireGuard stats
    if command -v wg >/dev/null 2>&1; then
      local stats
      stats=$(wg show velum 2>/dev/null || echo "")
      if [[ -n "$stats" ]]; then
        local rx tx handshake
        rx=$(echo "$stats" | grep "transfer:" | awk '{print $2, $3}')
        tx=$(echo "$stats" | grep "transfer:" | awk '{print $5, $6}')
        handshake=$(echo "$stats" | grep "latest handshake:" | cut -d: -f2- | xargs)

        [[ -n "$rx" ]] && echo "  Data RX:      $rx"
        [[ -n "$tx" ]] && echo "  Data TX:      $tx"
        [[ -n "$handshake" ]] && echo "  Last shake:   $handshake"
      fi
    fi
  else
    echo "  Status:       ${C_RED}DISCONNECTED${C_RESET}"
  fi

  echo

  # Security status
  echo "Security:"

  # Kill switch (requires root to query firewall rules accurately)
  if [[ $EUID -ne 0 ]]; then
    echo "  Kill switch:  ${C_YELLOW}Unknown${C_RESET} (run with sudo)"
  else
    local ks_status
    ks_status=$(os_killswitch_status 2>/dev/null || echo "unknown")
    case "$ks_status" in
      active)
        local rule_count
        rule_count=$(os_killswitch_rule_count 2>/dev/null || echo "?")
        echo "  Kill switch:  ${C_GREEN}ACTIVE${C_RESET} ($rule_count rules)"
        ;;
      inactive)
        echo "  Kill switch:  ${C_YELLOW}INACTIVE${C_RESET}"
        ;;
      *)
        echo "  Kill switch:  ${C_DIM}Unknown${C_RESET}"
        ;;
    esac
  fi

  # IPv6
  if os_ipv6_enabled 2>/dev/null; then
    echo "  IPv6:         ${C_YELLOW}ENABLED${C_RESET} (potential leak)"
  else
    echo "  IPv6:         ${C_GREEN}DISABLED${C_RESET}"
  fi

  # DNS
  local dns_servers
  dns_servers=$(os_get_dns 2>/dev/null | head -1)
  if [[ "$dns_servers" == "10.0.0.243" || "$dns_servers" == "10.0.0.242" ]]; then
    echo "  DNS:          ${C_GREEN}PIA${C_RESET} ($dns_servers)"
  elif [[ "$dns_servers" == "10.64.0.1" ]]; then
    echo "  DNS:          ${C_GREEN}Mullvad${C_RESET} ($dns_servers)"
  elif [[ "$dns_servers" == "10.0.254.1" ]]; then
    echo "  DNS:          ${C_GREEN}IVPN${C_RESET} ($dns_servers)"
  elif [[ -n "$dns_servers" ]]; then
    echo "  DNS:          $dns_servers"
  else
    echo "  DNS:          ${C_DIM}System default${C_RESET}"
  fi

  echo

  # Port forwarding (root-only runtime files)
  if [[ -f "$VELUM_RUN_DIR/pf.pid" ]]; then
    if [[ ! -r "$VELUM_RUN_DIR/pf.pid" ]]; then
      echo "Port Forward:   ${C_YELLOW}Unknown${C_RESET} (run with sudo)"
    else
      local pf_pid
      pf_pid=$(cat "$VELUM_RUN_DIR/pf.pid" 2>/dev/null || echo "")
      if [[ -n "$pf_pid" ]] && kill -0 "$pf_pid" 2>/dev/null; then
        echo "Port Forward:   ${C_GREEN}ACTIVE${C_RESET} (PID: $pf_pid)"
        # Show the port if available
        if [[ -f "$VELUM_RUN_DIR/pf.port" ]]; then
          local pf_port
          pf_port=$(cat "$VELUM_RUN_DIR/pf.port" 2>/dev/null || echo "")
          [[ -n "$pf_port" ]] && echo "Forwarded Port: ${C_GREEN}$pf_port${C_RESET}"
        fi
      else
        echo "Port Forward:   ${C_YELLOW}INACTIVE${C_RESET}"
      fi
    fi
  fi

  echo

  # Token status
  echo "Authentication:"
  local token_file
  token_file=$(get_token_file)
  if check_token_expiry "$token_file" 2>/dev/null; then
    echo "  Token:        ${C_GREEN}Valid${C_RESET}"
  else
    echo "  Token:        ${C_RED}Expired or missing${C_RESET}"
  fi

  echo
}

# ============================================================================
# HELP
# ============================================================================

show_help() {
  cat << 'EOF'
velum-status - Show VPN connection status

USAGE
    velum status          # Basic status (some details require sudo)
    sudo velum status     # Full status with all details

DESCRIPTION
    Displays current VPN connection status including:
    - Connection state (connected/disconnected)
    - Provider and VPN interface
    - Public IP address
    - WireGuard transfer statistics
    - Kill switch status (requires sudo)
    - IPv6 status
    - DNS configuration
    - Port forwarding status (requires sudo)
    - Authentication token validity

OPTIONS
    -h, --help    Show this help message

NOTE
    Some status details (kill switch, port forwarding) require sudo
    due to hardened runtime file permissions.

EXAMPLES
    velum status          # Quick status check
    sudo velum status     # Full status with security details

SEE ALSO
    velum test        # Comprehensive leak testing
    velum connect     # Connect to VPN
    velum disconnect  # Disconnect from VPN
EOF
}

# ============================================================================
# MAIN
# ============================================================================

main() {
  # Handle help flag
  case "${1:-}" in
    -h|--help)
      show_help
      exit 0
      ;;
  esac

  load_status_config
  show_status
}

main "$@"
