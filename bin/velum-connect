#!/usr/bin/env bash
# velum-connect - Connect to VPN using velum configuration
# Handles: server selection, WireGuard setup, kill switch, DNS

set -euo pipefail

# ============================================================================
# INITIALIZATION
# ============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VELUM_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
export VELUM_ROOT

# Source libraries
source "$VELUM_ROOT/lib/velum-core.sh"
source "$VELUM_ROOT/lib/velum-security.sh"
source "$VELUM_ROOT/lib/os/detect.sh"
source "$VELUM_ROOT/lib/providers/provider-base.sh"

# Dead-man switch
security_check "$0" || exit 1

# ============================================================================
# CONFIGURATION
# ============================================================================

# WireGuard config path
WG_CONF_PATH="/etc/wireguard/velum.conf"

# Runtime directory (VELUM_RUN_DIR from velum-core.sh is OS-specific)

# Configuration file (from velum-core.sh)
CONFIG_FILE="$VELUM_CONFIG_FILE"

# Configuration array
declare -A CONFIG

# Load configuration safely (no source - prevents code injection)
load_config() {
  if [[ ! -f "$CONFIG_FILE" ]]; then
    print_error "No configuration found. Run velum-config first."
    exit 1
  fi

  # Use safe parser instead of source to prevent code injection
  if ! safe_load_config "$CONFIG_FILE"; then
    print_error "Failed to parse configuration file."
    exit 1
  fi

  # Validate required settings
  if [[ -z "${CONFIG[provider]:-}" ]]; then
    print_error "Invalid configuration. Run velum-config again."
    exit 1
  fi

  # Validate killswitch_lan if set (prevents shell injection in PostUp)
  if [[ -n "${CONFIG[killswitch_lan]:-}" ]]; then
    if ! validate_killswitch_lan "${CONFIG[killswitch_lan]}"; then
      print_error "Invalid killswitch_lan value: ${CONFIG[killswitch_lan]}"
      print_error "Must be 'detect', 'block', or a valid CIDR (e.g., 192.168.1.0/24)"
      exit 1
    fi
  fi
}

# ============================================================================
# SERVER SELECTION
# ============================================================================

# Find best server by latency
find_best_server() {
  local allow_geo="${CONFIG[allow_geo]:-false}"
  local require_pf="${CONFIG[port_forward]:-false}"
  local max_latency="${CONFIG[max_latency]:-0.05}"

  log_info "Finding best server..."

  local filters=""
  [[ "$allow_geo" != "true" ]] && filters="--geo false"
  [[ "$require_pf" == "true" ]] && filters="$filters --port-forward true"

  local servers
  # shellcheck disable=SC2086
  servers=$(provider_filter_servers $filters) || {
    print_error "Failed to fetch server list"
    exit 1
  }

  local best_region=""
  local best_ip=""
  local best_hostname=""
  local best_latency=999999

  # Test up to 10 servers
  local count=0
  while IFS= read -r server; do
    local id name ip hostname latency

    # Handle different provider server list formats
    case "${CONFIG[provider]}" in
      mullvad)
        # Mullvad format: hostname, country_name, city_name, ipv4_addr_in
        id=$(echo "$server" | jq -r '.hostname')
        name=$(echo "$server" | jq -r '"\(.country_name) - \(.city_name)"')
        ip=$(echo "$server" | jq -r '.ipv4_addr_in // empty')
        hostname="$id"
        ;;
      ivpn)
        # IVPN format: gateway, country, city, hosts[0].hostname, hosts[0].host
        id=$(echo "$server" | jq -r '.hosts[0].hostname')
        name=$(echo "$server" | jq -r '"\(.country) - \(.city)"')
        ip=$(echo "$server" | jq -r '.hosts[0].host // empty')
        hostname="$id"
        ;;
      *)
        # PIA format: id, name, servers.wg[0].ip, servers.wg[0].cn
        id=$(echo "$server" | jq -r '.id')
        name=$(echo "$server" | jq -r '.name')
        ip=$(echo "$server" | jq -r '.servers.wg[0].ip // empty')
        hostname=$(echo "$server" | jq -r '.servers.wg[0].cn // empty')
        ;;
    esac

    [[ -z "$ip" ]] && continue

    echo -n "  Testing $name... "
    latency=$(provider_test_latency "$id" 2>/dev/null || echo "999999")
    echo "${latency}ms"

    # Compare as integers (multiply by 1000)
    local latency_int=${latency%.*}
    local best_int=${best_latency%.*}

    if [[ "$latency_int" -lt "$best_int" ]]; then
      best_region="$id"
      best_ip="$ip"
      best_hostname="$hostname"
      best_latency="$latency"
    fi

    ((count++))
    [[ $count -ge 10 ]] && break
  done < <(echo "$servers" | jq -c '.[]')

  if [[ -z "$best_ip" ]]; then
    print_error "No suitable server found"
    exit 1
  fi

  print_ok "Best server: $best_region (${best_latency}ms)"

  # Set selected server
  CONFIG[selected_region]="$best_region"
  CONFIG[selected_ip]="$best_ip"
  CONFIG[selected_hostname]="$best_hostname"
}

# ============================================================================
# WIREGUARD CONNECTION
# ============================================================================

# WireGuard key storage
WG_KEY_FILE="${VELUM_TOKENS_DIR}/wg_private_key"

# Generate or load WireGuard keypair
generate_wg_keys() {
  # Check if we have a saved key
  if [[ -f "$WG_KEY_FILE" ]]; then
    log_info "Loading existing WireGuard key..."
    WG_PRIVATE_KEY=$(cat "$WG_KEY_FILE")
    WG_PUBLIC_KEY=$(echo "$WG_PRIVATE_KEY" | wg pubkey)
    WG_KEY_REUSED=true
  else
    log_info "Generating WireGuard keys..."
    WG_PRIVATE_KEY=$(wg genkey)
    WG_PUBLIC_KEY=$(echo "$WG_PRIVATE_KEY" | wg pubkey)

    # Save the key for future use
    ensure_config_dir "$VELUM_TOKENS_DIR" 700
    echo "$WG_PRIVATE_KEY" > "$WG_KEY_FILE"
    chmod 600 "$WG_KEY_FILE"

    # Fix ownership if running as root via sudo
    if [[ -n "${SUDO_USER:-}" ]]; then
      local sudo_uid sudo_gid
      sudo_uid=$(id -u "$SUDO_USER" 2>/dev/null)
      sudo_gid=$(id -g "$SUDO_USER" 2>/dev/null)
      if [[ -n "$sudo_uid" && -n "$sudo_gid" ]]; then
        chown "$sudo_uid:$sudo_gid" "$WG_KEY_FILE"
      fi
    fi

    WG_KEY_REUSED=false
  fi

  # Mark for cleanup
  mark_sensitive WG_PRIVATE_KEY
}

# Create WireGuard configuration file
create_wg_config() {
  local peer_ip="$1"
  local server_key="$2"
  local server_port="$3"
  local server_ip="$4"
  local dns_server="${5:-}"

  log_info "Creating WireGuard configuration..."

  # Ensure directory exists with proper permissions
  mkdir -p "$(dirname "$WG_CONF_PATH")"
  chmod 700 "$(dirname "$WG_CONF_PATH")"

  # Build config
  local config="[Interface]
Address = $peer_ip
PrivateKey = $WG_PRIVATE_KEY"

  # Add DNS with encrypted fallback
  # Primary: VPN provider DNS (e.g., PIA 10.0.0.243)
  # Secondary: Quad9 (9.9.9.9) - routed through tunnel for encryption
  #
  # On Linux, we skip DNS in WireGuard config because wg-quick tries to use
  # resolvconf which may not be installed. Instead, velum manages DNS directly
  # via os_set_dns() after WireGuard starts.
  if [[ -n "$dns_server" && "$VELUM_OS" != "linux" ]]; then
    config="$config
DNS = $dns_server, 9.9.9.9"
  fi

  # Add PostUp for kill switch
  if [[ "${CONFIG[killswitch]:-false}" == "true" ]]; then
    local ks_cmd="$VELUM_ROOT/bin/velum-killswitch enable"
    ks_cmd="$ks_cmd --vpn-ip $server_ip"
    ks_cmd="$ks_cmd --vpn-port $server_port"
    ks_cmd="$ks_cmd --vpn-iface %i"
    ks_cmd="$ks_cmd --lan-policy ${CONFIG[killswitch_lan]:-detect}"

    config="$config
PostUp = $ks_cmd"
  fi

  # Add PostDown for kill switch
  if [[ "${CONFIG[killswitch]:-false}" == "true" ]]; then
    config="$config
PostDown = $VELUM_ROOT/bin/velum-killswitch disable
PostDown = $VELUM_ROOT/bin/velum-killswitch notify"
  fi

  # Add DNS route fix - ensure DNS goes through tunnel
  # PIA uses 10.0.0.243 which may conflict with common LAN subnets
  if [[ -n "$dns_server" ]]; then
    if [[ "$(uname)" == "Darwin" ]]; then
      config="$config
PostUp = route -q -n add -host $dns_server -interface %i 2>/dev/null || true
PostUp = route -q -n add -host 9.9.9.9 -interface %i 2>/dev/null || true"
    else
      # Linux: add host routes for DNS servers through VPN interface
      config="$config
PostUp = ip route add $dns_server/32 dev %i 2>/dev/null || true
PostUp = ip route add 9.9.9.9/32 dev %i 2>/dev/null || true
PostDown = ip route del $dns_server/32 dev %i 2>/dev/null || true
PostDown = ip route del 9.9.9.9/32 dev %i 2>/dev/null || true"
    fi
  fi

  # Peer section
  config="$config

[Peer]
PublicKey = $server_key
AllowedIPs = 0.0.0.0/0
Endpoint = $server_ip:$server_port
PersistentKeepalive = 25"

  # Write config with secure permissions
  (
    umask 077
    echo "$config" > "$WG_CONF_PATH"
  )
  chmod 600 "$WG_CONF_PATH"

  print_ok "WireGuard config written to $WG_CONF_PATH"
}

# Bring up WireGuard interface
start_wireguard() {
  log_info "Starting WireGuard..."

  # Bring down existing connection if any
  wg-quick down "$WG_CONF_PATH" 2>/dev/null || true

  # Bring up new connection
  if ! wg-quick up "$WG_CONF_PATH"; then
    print_error "Failed to start WireGuard"
    exit 1
  fi

  print_ok "WireGuard interface is up!"
}

# ============================================================================
# PRE-CONNECTION SETUP
# ============================================================================

# Disable IPv6 if configured
setup_ipv6() {
  if [[ "${CONFIG[ipv6_disabled]:-false}" == "true" ]]; then
    log_info "Disabling IPv6 on interfaces..."
    if os_disable_ipv6; then
      print_ok "IPv6 disabled on all interfaces"
    else
      print_warn "Could not disable IPv6 on some interfaces"
    fi
  fi
}

# ============================================================================
# PORT FORWARDING
# ============================================================================

start_port_forwarding() {
  if [[ "${CONFIG[port_forward]:-false}" != "true" ]]; then
    return 0
  fi

  log_info "Setting up port forwarding..."

  local server_ip="${CONFIG[selected_ip]}"
  local hostname="${CONFIG[selected_hostname]}"

  # Get signature
  local pf_response
  pf_response=$(provider_enable_pf "$server_ip" "$hostname") || {
    print_error "Failed to get port forwarding signature"
    return 1
  }

  local payload signature port expires_at
  payload=$(echo "$pf_response" | jq -r '.payload')
  signature=$(echo "$pf_response" | jq -r '.signature')
  port=$(echo "$payload" | base64 -d | jq -r '.port')
  expires_at=$(echo "$payload" | base64 -d | jq -r '.expires_at')

  print_ok "Port forwarding enabled!"
  echo
  echo "  Forwarded port: ${C_GREEN}$port${C_RESET}"
  echo "  Expires: $expires_at"
  echo

  # Start refresh loop in background
  (
    while true; do
      sleep 900  # 15 minutes
      provider_refresh_pf "$server_ip" "$hostname" "$payload" "$signature" >/dev/null 2>&1 || break
    done
  ) &

  PF_PID=$!
  ensure_run_dir
  echo "$PF_PID" > "$VELUM_RUN_DIR/pf.pid"
  chmod 600 "$VELUM_RUN_DIR/pf.pid"
  echo "$port" > "$VELUM_RUN_DIR/pf.port"
  chmod 600 "$VELUM_RUN_DIR/pf.port"
  echo "Port forwarding keepalive running (PID: $PF_PID)"
}

# ============================================================================
# CONNECTION STATUS
# ============================================================================

show_connection_info() {
  echo
  print_section "CONNECTION ESTABLISHED"

  echo "Server:     ${CONFIG[selected_region]} (${CONFIG[selected_ip]})"

  # Get assigned IP
  local vpn_iface
  vpn_iface=$(os_detect_vpn_interface)
  if [[ -n "$vpn_iface" ]]; then
    echo "Interface:  $vpn_iface"
  fi

  # Security status
  echo
  echo "Security:"
  if [[ "${CONFIG[killswitch]:-false}" == "true" ]]; then
    echo "  Kill switch:  ${C_GREEN}ACTIVE${C_RESET}"
  else
    echo "  Kill switch:  ${C_YELLOW}DISABLED${C_RESET}"
  fi

  if [[ "${CONFIG[ipv6_disabled]:-false}" == "true" ]]; then
    echo "  IPv6:         ${C_GREEN}BLOCKED${C_RESET}"
  fi

  if [[ "${CONFIG[use_provider_dns]:-false}" == "true" ]]; then
    local dns_server
    dns_server=$(provider_get_dns | head -1)
    echo "  DNS:          $(provider_name) ($dns_server)"
  fi

  echo
  echo "To disconnect:"
  echo "  ${C_GREEN}sudo velum-disconnect${C_RESET}"
  echo
  echo "To check status:"
  echo "  ${C_GREEN}sudo velum-status${C_RESET}"
  echo
}

# ============================================================================
# HELP
# ============================================================================

show_help() {
  cat << 'EOF'
velum-connect - Connect to VPN

USAGE
    sudo velum connect

DESCRIPTION
    Establishes a VPN connection using the saved configuration from velum config.

    This command:
    1. Loads configuration from ~/.config/velum/velum.conf
    2. Finds best server by latency (if auto mode)
    3. Generates/loads WireGuard keypair
    4. Exchanges keys with provider API
    5. Creates WireGuard configuration
    6. Enables kill switch (if configured)
    7. Starts WireGuard interface
    8. Sets up port forwarding (if enabled)
    9. Starts background health monitor

REQUIREMENTS
    - Root privileges (sudo)
    - Valid configuration (run velum config first)
    - Valid authentication token

OPTIONS
    -h, --help    Show this help message

EXAMPLES
    sudo velum connect    # Connect using saved configuration

SEE ALSO
    velum config          # Configure VPN settings
    velum disconnect      # Disconnect from VPN
    velum status          # Check connection status
    velum test            # Test for leaks
EOF
}

# ============================================================================
# MAIN
# ============================================================================

main() {
  # Handle help flag
  case "${1:-}" in
    -h|--help)
      show_help
      exit 0
      ;;
  esac

  echo
  echo "${C_BOLD}velum-connect${C_RESET}"
  echo "============="
  echo

  # Require root
  require_root

  # Check requirements
  require_cmd wg-quick wireguard-tools
  require_cmd wg wireguard-tools  # Needed for key generation
  require_cmd curl curl
  require_cmd jq jq

  # Load configuration
  load_config

  # Load provider
  load_provider "${CONFIG[provider]}" || exit 1

  # Determine provider-specific token file
  local token_file="$VELUM_TOKEN_FILE"
  case "${CONFIG[provider]}" in
    mullvad) token_file="${VELUM_TOKENS_DIR}/mullvad_token" ;;
    ivpn) token_file="${VELUM_TOKENS_DIR}/ivpn_token" ;;
  esac

  # Check token (provider-specific)
  if ! check_token_expiry "$token_file"; then
    print_error "Authentication token expired. Run velum-config to re-authenticate."
    exit 1
  fi

  # Server selection
  if [[ "${CONFIG[server_auto]:-true}" == "true" ]] && [[ -z "${CONFIG[selected_ip]:-}" ]]; then
    find_best_server
  elif [[ -z "${CONFIG[selected_ip]:-}" ]]; then
    print_error "No server selected. Run velum-config to select a server."
    exit 1
  fi

  echo "Connecting to: ${CONFIG[selected_region]} (${CONFIG[selected_ip]})"
  echo

  # Pre-connection setup
  setup_ipv6

  # Generate WireGuard keys
  generate_wg_keys

  # Exchange keys with provider
  local wg_response
  wg_response=$(provider_wg_exchange \
    "${CONFIG[selected_ip]}" \
    "${CONFIG[selected_hostname]}" \
    "$WG_PUBLIC_KEY" \
    "${CONFIG[dip_token]:-}") || {
    print_error "WireGuard key exchange failed"
    exit 1
  }

  # Extract connection parameters
  local peer_ip server_key server_port dns_server
  peer_ip=$(echo "$wg_response" | jq -r '.peer_ip')
  server_key=$(echo "$wg_response" | jq -r '.server_key')
  server_port=$(echo "$wg_response" | jq -r '.server_port')

  if [[ "${CONFIG[use_provider_dns]:-false}" == "true" ]]; then
    dns_server=$(echo "$wg_response" | jq -r '.dns_servers[0]')
  else
    dns_server=""
  fi

  # Validate API response fields before using in WireGuard config
  # This prevents newline injection and other attacks from compromised API responses
  if ! validate_ipv4_cidr "$peer_ip"; then
    print_error "Invalid peer_ip from API: $peer_ip"
    exit 1
  fi
  if ! validate_wg_key "$server_key"; then
    print_error "Invalid server_key from API"
    exit 1
  fi
  if ! validate_port "$server_port"; then
    print_error "Invalid server_port from API: $server_port"
    exit 1
  fi
  if [[ -n "$dns_server" ]] && ! validate_ipv4 "$dns_server"; then
    print_error "Invalid DNS server from API: $dns_server"
    exit 1
  fi

  # Create WireGuard config
  create_wg_config "$peer_ip" "$server_key" "$server_port" "${CONFIG[selected_ip]}" "$dns_server"

  # Clear private key from memory (it's now in config file)
  unset WG_PRIVATE_KEY

  # Start WireGuard
  start_wireguard

  # Set DNS on Linux (we handle it directly instead of via wg-quick/resolvconf)
  if [[ "$VELUM_OS" == "linux" && -n "$dns_server" ]]; then
    log_info "Configuring DNS via velum..."
    if os_set_dns "$dns_server" "9.9.9.9"; then
      print_ok "DNS configured ($dns_server, 9.9.9.9)"
    else
      print_warn "Could not configure DNS - manual setup may be required"
    fi
  fi

  # Port forwarding
  start_port_forwarding

  # Start background monitor
  if [[ -x "$SCRIPT_DIR/velum-monitor" ]]; then
    "$SCRIPT_DIR/velum-monitor" start >/dev/null 2>&1 || true
  fi

  # Show connection info
  show_connection_info
}

main "$@"
