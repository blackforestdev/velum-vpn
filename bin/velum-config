#!/usr/bin/env bash
# velum-config - Interactive VPN configuration for velum-vpn
# Implements the 5-phase configuration flow:
#   Phase 1: Authentication
#   Phase 2: Security Profile
#   Phase 3: Connection Features
#   Phase 4: Server Selection
#   Phase 5: Connect

set -euo pipefail

# ============================================================================
# INITIALIZATION
# ============================================================================

# Detect script location and VELUM_ROOT
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VELUM_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
export VELUM_ROOT

# Source libraries
source "$VELUM_ROOT/lib/velum-core.sh"
source "$VELUM_ROOT/lib/velum-security.sh"
source "$VELUM_ROOT/lib/velum-jurisdiction.sh"
source "$VELUM_ROOT/lib/velum-detection.sh"
source "$VELUM_ROOT/lib/os/detect.sh"
source "$VELUM_ROOT/lib/providers/provider-base.sh"

# Dead-man switch
security_check "$0" || exit 1

# ============================================================================
# CONFIGURATION STATE
# ============================================================================

# These variables hold the configuration built through the phases
declare -A CONFIG=(
  # Provider
  [provider]=""

  # Credentials (cleared after auth)
  [username]=""
  [password]=""
  [token]=""

  # Security
  [killswitch]="true"
  [killswitch_lan]="detect"
  [ipv6_disabled]="true"
  [use_provider_dns]="true"

  # Features
  [dip_enabled]="false"
  [dip_token]=""
  [port_forward]="false"

  # Server
  [allow_geo]="false"
  [server_auto]="true"
  [max_latency]="0.05"
  [selected_region]=""
  [selected_ip]=""
  [selected_hostname]=""
)

# Configuration file path (from velum-core.sh)
CONFIG_FILE="$VELUM_CONFIG_FILE"

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

# Load existing configuration if present
load_config() {
  if [[ -f "$CONFIG_FILE" ]]; then
    log_info "Loading existing configuration..."
    # Use safe parser with strict mode - warn but continue if config is corrupt
    if ! safe_load_config "$CONFIG_FILE" --strict --known-keys-only 2>/dev/null; then
      print_warn "Failed to parse existing config; continuing with defaults."
      print_warn "Run 'velum config lint' to diagnose issues."
    fi
  fi
}

# Save configuration to file
save_config() {
  log_info "Saving configuration..."

  # Initialize config directories with proper permissions
  init_config_dirs

  {
    echo "# velum-vpn configuration"
    echo "# Generated: $(date)"
    echo "# Location: $CONFIG_FILE"
    echo ""
    echo "# Provider"
    echo "CONFIG[provider]=\"${CONFIG[provider]}\""
    echo ""
    echo "# Security"
    echo "CONFIG[killswitch]=\"${CONFIG[killswitch]}\""
    echo "CONFIG[killswitch_lan]=\"${CONFIG[killswitch_lan]}\""
    echo "CONFIG[ipv6_disabled]=\"${CONFIG[ipv6_disabled]}\""
    echo "CONFIG[use_provider_dns]=\"${CONFIG[use_provider_dns]}\""
    echo ""
    echo "# Features"
    echo "CONFIG[dip_enabled]=\"${CONFIG[dip_enabled]}\""
    echo "CONFIG[dip_token]=\"${CONFIG[dip_token]}\""
    echo "CONFIG[port_forward]=\"${CONFIG[port_forward]}\""
    echo ""
    echo "# Server"
    echo "CONFIG[allow_geo]=\"${CONFIG[allow_geo]}\""
    echo "CONFIG[server_auto]=\"${CONFIG[server_auto]}\""
    echo "CONFIG[max_latency]=\"${CONFIG[max_latency]}\""
    echo "CONFIG[selected_region]=\"${CONFIG[selected_region]}\""
    echo "CONFIG[selected_ip]=\"${CONFIG[selected_ip]}\""
    echo "CONFIG[selected_hostname]=\"${CONFIG[selected_hostname]}\""
  } > "$CONFIG_FILE"

  chmod 600 "$CONFIG_FILE"

  # Fix ownership if running as root via sudo
  # Note: _validate_username is defined in velum-core.sh
  if [[ -n "${SUDO_USER:-}" ]] && _validate_username "$SUDO_USER"; then
    local sudo_uid sudo_gid
    sudo_uid=$(id -u "$SUDO_USER" 2>/dev/null)
    sudo_gid=$(id -g "$SUDO_USER" 2>/dev/null)
    if [[ -n "$sudo_uid" && -n "$sudo_gid" ]]; then
      chown "$sudo_uid:$sudo_gid" "$CONFIG_FILE"
    fi
  fi
}

# ============================================================================
# PHASE 0: PROVIDER SELECTION
# ============================================================================

phase_provider() {
  print_section "PROVIDER SELECTION"

  echo "Available VPN providers:"
  echo

  # List available providers
  local providers=()
  local i=1
  while IFS= read -r p; do
    providers+=("$p")
    local desc=""
    case "$p" in
      pia) desc="Private Internet Access - Port forwarding, Dedicated IP" ;;
      mullvad) desc="Mullvad VPN - Privacy-focused, no account info required" ;;
      ivpn) desc="IVPN - Privacy-focused, open source, audited" ;;
      *) desc="VPN Provider" ;;
    esac
    echo "  $i. ${p^^} - $desc"
    ((i++)) || true
  done < <(list_providers)

  echo

  # Check for existing config
  if [[ -n "${CONFIG[provider]}" ]]; then
    print_info "Current provider: ${CONFIG[provider]^^}"
    if ask_yn "Keep current provider?" "y"; then
      return
    fi
  fi

  # Select provider
  local choice
  if ! read -r -p "Select provider [1-${#providers[@]}]: " choice; then
    echo -e "\n\nCancelled."
    exit 130
  fi

  if [[ "$choice" =~ ^[0-9]+$ ]] && [[ "$choice" -ge 1 ]] && [[ "$choice" -le "${#providers[@]}" ]]; then
    CONFIG[provider]="${providers[$((choice-1))]}"
  else
    CONFIG[provider]="pia"  # Default
  fi

  print_ok "Selected: ${CONFIG[provider]^^}"
  echo
}

# ============================================================================
# PHASE 1: AUTHENTICATION
# ============================================================================

phase_authentication() {
  print_section "PHASE 1: AUTHENTICATION"

  # Load provider
  load_provider "${CONFIG[provider]}" || exit 1
  echo "Provider: $(provider_name)"
  echo

  # Get auth type for this provider
  local auth_type
  auth_type=$(provider_auth_type)

  # Determine provider-specific token file
  local token_file="$VELUM_TOKEN_FILE"
  case "${CONFIG[provider]}" in
    mullvad) token_file="${VELUM_TOKENS_DIR}/mullvad_token" ;;
    ivpn) token_file="${VELUM_TOKENS_DIR}/ivpn_token" ;;
  esac

  # Check for existing token (provider-specific)
  if check_token_expiry "$token_file"; then
    local token
    token=$(read_token "$token_file")
    if [[ -n "$token" ]]; then
      print_ok "Valid authentication token found."
      CONFIG[token]="$token"

      if ! ask_yn "Use existing token?" "y"; then
        CONFIG[token]=""
      fi
    fi
  fi

  # Need to authenticate?
  if [[ -z "${CONFIG[token]}" ]]; then
    case "$auth_type" in
      username_password)
        _auth_username_password
        ;;
      account_number)
        _auth_account_number
        ;;
      *)
        print_error "Unknown authentication type: $auth_type"
        exit 1
        ;;
    esac
  fi

  echo
}

# Username/password authentication (PIA style)
_auth_username_password() {
  local creds_file
  creds_file="$(os_get_home)/.${CONFIG[provider]}_credentials"

  # Try to load credentials from file
  if [[ -f "$creds_file" ]]; then
    print_info "Found credentials file: $creds_file"
    CONFIG[username]=$(sed -n '1p' "$creds_file" 2>/dev/null || echo "")
    CONFIG[password]=$(sed -n '2p' "$creds_file" 2>/dev/null || echo "")
  fi

  # Prompt for credentials if not loaded
  if [[ -z "${CONFIG[username]}" ]]; then
    local prompt="Username"
    [[ "${CONFIG[provider]}" == "pia" ]] && prompt="PIA username (p#######)"
    CONFIG[username]=$(ask_input "$prompt")
  fi

  if [[ -z "${CONFIG[password]}" ]]; then
    CONFIG[password]=$(ask_password "Password")
  fi

  # Authenticate
  local auth_result
  if auth_result=$(provider_authenticate "${CONFIG[username]}" "${CONFIG[password]}"); then
    CONFIG[token]=$(echo "$auth_result" | jq -r '.token // .access_token')
    local expiry
    expiry=$(echo "$auth_result" | jq -r '.expires_at // .expiry // "unknown"')
    print_ok "Authentication successful!"
    [[ "$expiry" != "unknown" && "$expiry" != "null" ]] && echo "Token expires: $expiry"
  else
    print_error "Authentication failed. Please check your credentials."
    exit 1
  fi

  # Clear credentials from memory - use unset to remove from shell memory
  # Setting to "" leaves the variable allocated; unset deallocates it
  unset 'CONFIG[username]' 'CONFIG[password]'
}

# Account number authentication (Mullvad style)
_auth_account_number() {
  local creds_file
  creds_file="$(os_get_home)/.${CONFIG[provider]}_credentials"

  # Try to load account from file
  if [[ -f "$creds_file" ]]; then
    print_info "Found credentials file: $creds_file"
    CONFIG[username]=$(sed -n '1p' "$creds_file" 2>/dev/null || echo "")
  fi

  # Prompt for account number if not loaded
  # NOTE: Account numbers are treated as sensitive (they're both username AND password)
  # Anyone with the number has full account access - mask input like a password
  if [[ -z "${CONFIG[username]}" ]]; then
    case "${CONFIG[provider]}" in
      mullvad)
        echo "Enter your Mullvad account number (16 digits)."
        echo "You can find this at https://mullvad.net/account"
        ;;
      ivpn)
        echo "Enter your IVPN account ID (format: i-XXXX-XXXX-XXXX)."
        echo "You can find this at https://www.ivpn.net/clientarea"
        ;;
      *)
        echo "Enter your account number/ID."
        ;;
    esac
    echo
    CONFIG[username]=$(ask_password "Account ID")
  fi

  # Authenticate
  local auth_result
  if auth_result=$(provider_authenticate "${CONFIG[username]}" ""); then
    CONFIG[token]=$(echo "$auth_result" | jq -r '.access_token // .token')
    local expiry
    expiry=$(echo "$auth_result" | jq -r '.expires_at // .expiry // "unknown"')
    print_ok "Authentication successful!"
    [[ "$expiry" != "unknown" && "$expiry" != "null" ]] && echo "Token expires: $expiry"
  else
    print_error "Authentication failed. Please check your account number."
    exit 1
  fi

  # Clear account number from memory - use unset to fully remove
  unset 'CONFIG[username]'
}

# ============================================================================
# PHASE 2: SECURITY PROFILE
# ============================================================================

phase_security() {
  print_section "PHASE 2: SECURITY PROFILE"

  # Explain kill switch
  echo "The kill switch blocks ALL internet traffic if the VPN drops,"
  echo "preventing your real IP from being exposed."
  echo
  echo "When enabled, the kill switch will also:"
  echo "  - Block IPv6 traffic at the firewall level"
  echo "  - Disable IPv6 on network interfaces"
  echo "  - Default to using $(provider_name)'s DNS servers"
  echo

  # Kill switch is the PRIMARY security decision
  if ask_yn "Enable kill switch?" "y"; then
    CONFIG[killswitch]="true"
    CONFIG[ipv6_disabled]="true"  # Auto-set when kill switch enabled

    print_ok "Kill switch will be enabled."
    echo "  IPv6 protection: Enabled (interface + firewall)"
    echo

    # LAN policy (only asked if kill switch enabled)
    echo "LAN Policy: Choose how to handle local network traffic."
    echo "  block  - Block all LAN traffic (most secure)"
    echo "  detect - Auto-detect and allow your local subnet"
    echo "  CIDR   - Specify a custom subnet (e.g., 10.0.1.0/24)"
    echo

    local lan_choice
    lan_choice=$(ask_input "LAN policy" "detect")
    CONFIG[killswitch_lan]="$lan_choice"

    if [[ "$lan_choice" == "detect" ]]; then
      local detected
      detected=$(os_detect_subnet 2>/dev/null || echo "")
      if [[ -n "$detected" ]]; then
        echo "Detected local subnet: $detected"
      else
        print_warn "Could not detect local subnet. LAN traffic may be blocked."
      fi
    fi

  else
    CONFIG[killswitch]="false"
    print_warn "Kill switch DISABLED - VPN drops may expose your real IP!"
    echo

    # IPv6 asked separately when kill switch is off
    echo "IPv6 can leak your real IP even when VPN is connected."
    if ask_yn "Disable IPv6?" "y"; then
      CONFIG[ipv6_disabled]="true"
    else
      CONFIG[ipv6_disabled]="false"
    fi
  fi

  echo

  # DNS (always asked, but with smart default)
  echo "Using third-party DNS could allow DNS monitoring."
  local dns_default="y"
  if [[ "${CONFIG[killswitch]}" == "true" ]]; then
    echo "(Recommended: Yes, since kill switch is enabled)"
  fi

  if ask_yn "Use $(provider_name) DNS servers?" "$dns_default"; then
    CONFIG[use_provider_dns]="true"
  else
    CONFIG[use_provider_dns]="false"
    print_warn "Using system DNS - DNS queries may be visible to ISP."
  fi

  echo
}

# ============================================================================
# PHASE 3: CONNECTION FEATURES
# ============================================================================

phase_features() {
  print_section "PHASE 3: CONNECTION FEATURES"

  # Check if provider has any optional features
  local has_dip=false
  local has_pf=false
  provider_supports_dip && has_dip=true
  provider_supports_pf && has_pf=true

  if [[ "$has_dip" != "true" && "$has_pf" != "true" ]]; then
    echo "$(provider_name) does not offer Dedicated IP or port forwarding."
    echo "No optional features to configure."
    echo
    return
  fi

  # Dedicated IP
  if provider_supports_dip; then
    echo "Dedicated IP provides a static IP address for your connection."
    if ask_yn "Use Dedicated IP?" "n"; then
      CONFIG[dip_enabled]="true"

      local dip_token
      dip_token=$(ask_input "DIP token")

      # Validate DIP token
      if provider_get_dip "$dip_token" >/dev/null 2>&1; then
        CONFIG[dip_token]="$dip_token"
        print_ok "DIP token validated successfully!"

        # DIP may not support port forwarding
        local dip_info
        dip_info=$(provider_get_dip "$dip_token")
        local dip_pf
        dip_pf=$(echo "$dip_info" | jq -r '.port_forward // false')
        if [[ "$dip_pf" != "true" ]]; then
          print_warn "Note: Your DIP does not support port forwarding."
          CONFIG[port_forward]="false"
        fi
      else
        print_error "Invalid DIP token. Continuing without DIP."
        CONFIG[dip_enabled]="false"
      fi
    fi
    echo
  fi

  # Port forwarding (skip if DIP doesn't support it)
  if [[ "${CONFIG[dip_enabled]}" != "true" ]] || [[ -z "${CONFIG[dip_token]}" ]]; then
    if provider_supports_pf; then
      echo "Port forwarding allows incoming connections to your device."
      echo "Note: Not available on US servers."
      if ask_yn "Enable port forwarding?" "n"; then
        CONFIG[port_forward]="true"
      else
        CONFIG[port_forward]="false"
      fi
      echo
    fi
  fi
}

# ============================================================================
# PHASE 4: SERVER SELECTION
# ============================================================================

# Sanitize untrusted API strings for safe display and storage.
# Strips control characters (ANSI escapes, etc.) and replaces field delimiters.
_sanitize_field() {
  local value="$1"
  # Remove control characters (0x00-0x1F, 0x7F) to prevent terminal injection
  # Replace pipe delimiter to prevent field parsing issues
  value=$(printf '%s' "$value" | tr -d '[:cntrl:]' | tr '|' '/')
  printf '%s' "$value"
}

# Helper: Extract server data by provider format
# Output format: id|name|ip|hostname|country_code|host_provider|owned
# Note: country_code is used for alliance/privacy lookups; name contains display name
_extract_server_data() {
  local server="$1"
  local provider="$2"
  local id name ip hostname country_code host_provider owned

  case "$provider" in
    mullvad)
      id=$(echo "$server" | jq -r '.hostname')
      name=$(echo "$server" | jq -r '"\(.country_name) - \(.city_name)"')
      ip=$(echo "$server" | jq -r '.ipv4_addr_in // empty')
      hostname="$id"
      # Use country_code (e.g., "US") for alliance/privacy lookups, not country_name
      country_code=$(echo "$server" | jq -r '.country_code // empty' | tr '[:lower:]' '[:upper:]')
      # Normalize host_provider: trim whitespace (preserve internal spaces), lowercase for matching
      host_provider=$(echo "$server" | jq -r '.provider // "unknown"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | tr '[:upper:]' '[:lower:]')
      owned=$(echo "$server" | jq -r '.owned // false')
      ;;
    ivpn)
      id=$(echo "$server" | jq -r '.hosts[0].hostname')
      name=$(echo "$server" | jq -r '"\(.country) - \(.city)"')
      ip=$(echo "$server" | jq -r '.hosts[0].host // empty')
      hostname="$id"
      # IVPN uses country name; extract country code if available, else use name
      country_code=$(echo "$server" | jq -r '.country_code // empty' | tr '[:lower:]' '[:upper:]')
      if [[ -z "$country_code" ]]; then
        # Fallback: use country name (less reliable for lookups)
        country_code=$(echo "$server" | jq -r '.country // empty')
      fi
      # IVPN doesn't expose provider/owned - mark as unknown
      host_provider="unknown"
      owned="unknown"
      ;;
    *)  # PIA
      id=$(echo "$server" | jq -r '.id')
      name=$(echo "$server" | jq -r '.name')
      ip=$(echo "$server" | jq -r '.servers.wg[0].ip // empty')
      hostname=$(echo "$server" | jq -r '.servers.wg[0].cn // empty')
      # PIA names are like "US New York" - extract country code prefix
      country_code="${name%% *}"
      # PIA doesn't expose provider/owned - mark as unknown
      host_provider="unknown"
      owned="unknown"
      ;;
  esac

  # Sanitize user-facing fields to prevent control char injection and delimiter issues
  name=$(_sanitize_field "$name")
  host_provider=$(_sanitize_field "$host_provider")

  # Output: id|name|ip|hostname|country_code|host_provider|owned
  echo "${id}|${name}|${ip}|${hostname}|${country_code}|${host_provider}|${owned}"
}

# Helper: Check detection status for servers before display
# Usage: _check_server_detection max_check entry1 entry2 ...
_check_server_detection() {
  local max_check="${1:-30}"
  shift
  local entries=("$@")

  # Collect unique IPs to check
  local ips_to_check=()
  local checked_ips=""
  local i=0

  for entry in "${entries[@]}"; do
    [[ $i -ge $max_check ]] && break

    local ip
    ip=$(echo "$entry" | cut -d'|' -f4)
    [[ -z "$ip" || "$ip" == "null" ]] && continue

    # Skip if already in our list or cached
    if [[ "$checked_ips" != *"|$ip|"* ]]; then
      local cached
      cached=$(get_cached_detection "$ip" 2>/dev/null || true)
      if [[ -z "$cached" ]]; then
        ips_to_check+=("$ip")
      fi
      checked_ips="${checked_ips}|${ip}|"
    fi
    ((i++)) || true
  done

  local total=${#ips_to_check[@]}
  if [[ $total -eq 0 ]]; then
    echo "Detection results cached for all servers."
    return 0
  fi

  echo "Checking detection status for $total unique IPs..."
  echo -n "Progress: "

  local count=0
  for ip in "${ips_to_check[@]}"; do
    # Run check (this caches the result)
    check_detection "$ip" >/dev/null 2>&1
    ((count++)) || true

    # Show progress
    local pct=$((count * 100 / total))
    echo -ne "\rProgress: ${count}/${total} (${pct}%) "
  done

  echo -e "\rProgress: Complete!              "
}

# Helper: Display enhanced server table
# Usage: _display_server_table max_display entry1 entry2 entry3 ...
_display_server_table() {
  local max_display="${1:-30}"
  shift
  local entries=("$@")

  echo
  echo "Server Selection (sorted by latency):"
  echo "──────────────────────────────────────────────────────────────────────────────────────────"
  printf "  %-3s %7s   %-24s %-8s %-5s %-4s %-3s %s\n" "#" "Latency" "Location" "Alliance" "Priv" "Host" "Det" "Rec"
  echo "──────────────────────────────────────────────────────────────────────────────────────────"

  local i=1
  for entry in "${entries[@]}"; do
    [[ $i -gt $max_display ]] && break

    # Parse entry: latency|id|name|ip|hostname|country_code|host_provider|owned
    local latency id name ip hostname country_code host_provider owned
    IFS='|' read -r latency id name ip hostname country_code host_provider owned <<< "$entry"

    # Get jurisdiction info
    local alliance privacy_rating privacy_bar
    alliance=$(get_alliance "$country_code")
    privacy_rating=$(get_privacy "$country_code")
    privacy_bar=$(privacy_to_bar "$privacy_rating")

    # Get host provider status symbol
    local host_sym
    host_sym=$(provider_to_symbol "$host_provider" "$owned" "$country_code")

    # Get detection status (from cache or "…" if not yet checked)
    local detection detection_sym
    detection=$(get_cached_detection "$ip")
    if [[ -n "$detection" ]]; then
      detection_sym=$(detection_to_symbol "$detection")
    else
      detection_sym="…"
      detection="checking"
    fi

    # Calculate recommendation (using v2 with provider jurisdiction)
    local rec rec_stars
    if [[ "$detection" != "checking" ]]; then
      rec=$(calculate_recommendation_v2 "$country_code" "$privacy_rating" "$detection" "$host_provider" "$owned")
    else
      rec=$(calculate_recommendation_v2 "$country_code" "$privacy_rating" "clean" "$host_provider" "$owned")
    fi
    rec_stars=$(recommendation_to_stars "$rec")

    # Format latency
    local latency_fmt
    if [[ "$latency" =~ ^[0-9]+$ ]]; then
      latency_fmt="${latency}ms"
    else
      latency_fmt="${latency}"
    fi

    # Truncate location if needed
    local loc_display="${name}"
    [[ ${#loc_display} -gt 24 ]] && loc_display="${loc_display:0:21}..."

    # Color code based on recommendation
    local row_color=""
    local reset="${C_RESET:-}"
    case "$rec" in
      3) row_color="${C_GREEN:-}" ;;
      2) row_color="" ;;
      1) row_color="${C_YELLOW:-}" ;;
      0) row_color="${C_RED:-}" ;;
    esac

    printf "%s%3d. %7s   %-24s %-8s %s  %s    %s   %s%s\n" \
      "$row_color" "$i" "$latency_fmt" "$loc_display" "$alliance" "$privacy_bar" "$host_sym" "$detection_sym" "$rec_stars" "$reset"

    ((i++)) || true
  done

  echo "──────────────────────────────────────────────────────────────────────────────────────────"
  echo
  print_jurisdiction_legend
  echo
}

phase_server() {
  print_section "PHASE 4: SERVER SELECTION"

  # Skip if DIP is configured (DIP has fixed server)
  if [[ "${CONFIG[dip_enabled]}" == "true" ]] && [[ -n "${CONFIG[dip_token]}" ]]; then
    local dip_info
    dip_info=$(provider_get_dip "${CONFIG[dip_token]}")
    CONFIG[selected_ip]=$(echo "$dip_info" | jq -r '.ip')
    CONFIG[selected_hostname]=$(echo "$dip_info" | jq -r '.cn')
    CONFIG[selected_region]="dip"
    print_info "Using Dedicated IP server: ${CONFIG[selected_ip]}"
    return
  fi

  # Geo servers (PIA-specific feature)
  if [[ "${CONFIG[provider]}" == "pia" ]]; then
    echo "Geo-located servers appear to be in a different country than"
    echo "their actual physical location (for censorship bypass)."
    if ask_yn "Allow geo-located servers?" "n"; then
      CONFIG[allow_geo]="true"
    else
      CONFIG[allow_geo]="false"
    fi
    echo
  fi

  # Server selection method
  echo "Server selection:"
  echo "  1. Auto (lowest latency, best recommendation)"
  echo "  2. Manual selection (view all servers with quality info)"
  echo

  local method
  method=$(ask_choice "Select method" "Auto (recommended)" "Manual selection")

  if [[ "$method" == "Auto"* ]]; then
    CONFIG[server_auto]="true"
    print_info "Will select server with best combination of latency and quality."
  else
    CONFIG[server_auto]="false"

    # Latency threshold
    local threshold
    threshold=$(ask_input "Maximum latency (ms)" "200")
    # Convert to ms if user entered seconds (e.g., 0.2)
    if [[ "$threshold" =~ ^0\.[0-9]+$ ]]; then
      threshold=$(awk "BEGIN {printf \"%.0f\", $threshold * 1000}")
    fi
    CONFIG[max_latency]="$threshold"

    # Get and display server list
    echo
    echo "Fetching server list and testing latency (threshold: ${threshold}ms)..."
    echo

    local filters=""
    [[ "${CONFIG[allow_geo]}" != "true" ]] && filters="--geo false"
    [[ "${CONFIG[port_forward]}" == "true" ]] && filters="$filters --port-forward true"

    local servers
    # shellcheck disable=SC2086
    servers=$(provider_filter_servers $filters)

    # Collect all servers with latency
    local server_data=()

    while IFS= read -r server; do
      local extracted id name ip hostname country_code host_provider owned latency

      extracted=$(_extract_server_data "$server" "${CONFIG[provider]}")
      IFS='|' read -r id name ip hostname country_code host_provider owned <<< "$extracted"

      [[ -z "$ip" || "$ip" == "null" ]] && continue

      # Test latency
      # TODO: UX improvement - show "(skip)" suffix for servers exceeding threshold
      #       Currently displays "207ms" even when threshold is 190ms, which is confusing.
      #       Fix: move echo after threshold check, show "${latency}ms (skip)" if exceeded.
      echo -n "  Testing $name... "
      latency=$(provider_test_latency "$id" 2>/dev/null || echo "9999")
      if [[ "$latency" =~ ^[0-9.]+$ ]]; then
        # Convert to integer ms if it's a float
        latency=$(printf "%.0f" "$latency" 2>/dev/null || echo "$latency")
        echo "${latency}ms"

        # Only include if within threshold
        if [[ "$latency" -le "$threshold" ]]; then
          # Store: latency|id|name|ip|hostname|country_code|host_provider|owned
          server_data+=("${latency}|${id}|${name}|${ip}|${hostname}|${country_code}|${host_provider}|${owned}")
        fi
      else
        echo "timeout"
      fi

    done < <(echo "$servers" | jq -c '.[]' | head -80)

    if [[ ${#server_data[@]} -eq 0 ]]; then
      print_warn "No servers found within ${threshold}ms latency threshold."
      print_info "Try increasing the maximum latency value."
      CONFIG[server_auto]="true"
      return
    fi

    # Sort by latency
    IFS=$'\n' sorted_data=($(printf '%s\n' "${server_data[@]}" | sort -t'|' -k1 -n))
    unset IFS

    echo
    echo "Found ${#sorted_data[@]} servers within ${threshold}ms threshold."
    echo

    # Check detection status for all servers before display
    local server_count=${#sorted_data[@]}
    _check_server_detection "$server_count" "${sorted_data[@]}"
    echo

    # Display enhanced table with detection results
    _display_server_table "$server_count" "${sorted_data[@]}"

    # Build selection arrays
    local region_ids=()
    local region_names=()
    local region_ips=()
    local region_hostnames=()

    local i=1
    for entry in "${sorted_data[@]}"; do
      local latency id name ip hostname country_code host_provider owned
      IFS='|' read -r latency id name ip hostname country_code host_provider owned <<< "$entry"
      region_ids+=("$id")
      region_names+=("$name")
      region_ips+=("$ip")
      region_hostnames+=("$hostname")
      ((i++)) || true
    done

    local choice
    if ! read -r -p "Select server number [1-$((i-1))]: " choice; then
      echo -e "\n\nCancelled."
      exit 130
    fi

    if [[ "$choice" =~ ^[0-9]+$ ]] && [[ "$choice" -ge 1 ]] && [[ "$choice" -lt "$i" ]]; then
      local idx=$((choice - 1))
      CONFIG[selected_region]="${region_ids[$idx]}"
      CONFIG[selected_ip]="${region_ips[$idx]}"
      CONFIG[selected_hostname]="${region_hostnames[$idx]}"
      print_ok "Selected: ${region_names[$idx]}"

      # Check for jurisdiction mismatch warning
      local selected_entry="${sorted_data[$idx]}"
      local _lat _id _name _ip _host _country_code _host_provider _owned
      IFS='|' read -r _lat _id _name _ip _host _country_code _host_provider _owned <<< "$selected_entry"

      if [[ "$_owned" == "false" && -n "$_host_provider" && "$_host_provider" != "unknown" ]]; then
        local mismatch
        mismatch=$(check_jurisdiction_mismatch "$_country_code" "$_host_provider" "$_owned")

        if [[ "$mismatch" == "5-EYES-HOSTED" ]]; then
          # Get display name from the entry
          local display_location="$_name"
          echo
          print_warn "JURISDICTION WARNING: This server claims '$display_location'"
          print_warn "but is hosted by $_host_provider (US-based, 5-Eyes jurisdiction)."
          print_warn "Traffic may route through US infrastructure despite the claimed location."
          echo
          if ! ask_yn "Continue with this selection?" "n"; then
            print_info "Server selection cancelled. Using auto mode."
            CONFIG[server_auto]="true"
            CONFIG[selected_region]=""
            CONFIG[selected_ip]=""
            CONFIG[selected_hostname]=""
          fi
        fi
      fi
    else
      print_error "Invalid selection. Using auto mode."
      CONFIG[server_auto]="true"
    fi
  fi

  echo
}

# ============================================================================
# PHASE 5: SUMMARY & CONNECT
# ============================================================================

phase_summary() {
  print_section "CONFIGURATION SUMMARY"

  echo "Provider:       ${C_BOLD}$(provider_name)${C_RESET}"
  echo

  echo "Security:"
  if [[ "${CONFIG[killswitch]}" == "true" ]]; then
    echo "  Kill switch:    ${C_GREEN}ENABLED${C_RESET} (LAN: ${CONFIG[killswitch_lan]})"
  else
    echo "  Kill switch:    ${C_RED}DISABLED${C_RESET}"
  fi

  if [[ "${CONFIG[ipv6_disabled]}" == "true" ]]; then
    echo "  IPv6:           ${C_GREEN}Disabled (interface + firewall)${C_RESET}"
  else
    echo "  IPv6:           ${C_YELLOW}Enabled (may leak)${C_RESET}"
  fi

  if [[ "${CONFIG[use_provider_dns]}" == "true" ]]; then
    local dns_server
    dns_server=$(provider_get_dns | head -1)
    echo "  DNS:            $(provider_name) ($dns_server)"
  else
    echo "  DNS:            System default"
  fi

  echo
  echo "Connection:"
  echo "  Protocol:       WireGuard"

  if [[ "${CONFIG[dip_enabled]}" == "true" ]]; then
    echo "  Server:         DIP (${CONFIG[selected_ip]})"
  elif [[ "${CONFIG[server_auto]}" == "true" ]]; then
    echo "  Server:         Auto (lowest latency)"
  else
    echo "  Server:         ${CONFIG[selected_region]} (${CONFIG[selected_ip]})"
  fi

  if [[ "${CONFIG[port_forward]}" == "true" ]]; then
    echo "  Port forward:   Yes"
  else
    echo "  Port forward:   No"
  fi

  echo
  echo "Press Enter to save configuration, or Ctrl+C to abort..."
  if ! read -r; then
    echo -e "\n\nCancelled."
    exit 130
  fi

  save_config
  print_ok "Configuration saved to $CONFIG_FILE"
  echo
  echo "To connect, run:"
  echo "  ${C_GREEN}sudo velum-connect${C_RESET}"
  echo
}

# ============================================================================
# SUBCOMMANDS
# ============================================================================

# Lint subcommand: validate config file
cmd_lint() {
  echo
  echo "${C_BOLD}velum-vpn Config Lint${C_RESET}"
  echo "====================="
  echo
  echo "Checking: $CONFIG_FILE"
  echo

  if [[ ! -f "$CONFIG_FILE" ]]; then
    print_error "Config file not found: $CONFIG_FILE"
    echo "Run 'velum config' to create a configuration."
    exit 1
  fi

  # Run lint mode (strict + known-keys-only, collects all errors)
  local result
  safe_load_config "$CONFIG_FILE" --lint
  result=$?

  # Exit codes: 0 = OK, 1 = errors, 2 = warnings
  exit $result
}

# Show usage
show_usage() {
  cat << 'EOF'
Usage: velum config [subcommand]

Subcommands:
  (none)    Run interactive configuration wizard
  lint      Validate existing configuration file

Examples:
  velum config         # Interactive wizard
  velum config lint    # Validate config file
EOF
}

# ============================================================================
# MAIN
# ============================================================================

main() {
  # Handle subcommands
  case "${1:-}" in
    lint)
      cmd_lint
      ;;
    -h|--help)
      show_usage
      exit 0
      ;;
    "")
      # No subcommand - run interactive wizard
      ;;
    *)
      print_error "Unknown subcommand: $1"
      show_usage
      exit 1
      ;;
  esac

  echo
  echo "${C_BOLD}velum-vpn Configuration${C_RESET}"
  echo "========================"
  echo

  # Migrate from legacy location if needed
  migrate_legacy_config

  # Check requirements
  check_os_requirements || exit 1

  # Check root for operations that need it
  if [[ "${CONFIG[killswitch]}" == "true" ]] || [[ "${CONFIG[ipv6_disabled]}" == "true" ]]; then
    if ! is_root; then
      print_warn "Note: Kill switch and IPv6 changes require root privileges."
      print_warn "You will be prompted for sudo password during connection."
    fi
  fi

  # Load existing config
  load_config

  # Run phases
  phase_provider
  phase_authentication
  phase_security
  phase_features
  phase_server
  phase_summary
}

# Run main
main "$@"
