#!/usr/bin/env bash
# velum-config - Interactive VPN configuration for velum-vpn
# Implements the 5-phase configuration flow:
#   Phase 1: Authentication
#   Phase 2: Security Profile
#   Phase 3: Connection Features
#   Phase 4: Server Selection
#   Phase 5: Connect

set -euo pipefail

# ============================================================================
# INITIALIZATION
# ============================================================================

# Detect script location and VELUM_ROOT
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VELUM_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
export VELUM_ROOT

# Source libraries
source "$VELUM_ROOT/lib/velum-core.sh"
source "$VELUM_ROOT/lib/velum-security.sh"
source "$VELUM_ROOT/lib/velum-credential.sh"
source "$VELUM_ROOT/lib/velum-vault.sh"
source "$VELUM_ROOT/lib/velum-jurisdiction.sh"
source "$VELUM_ROOT/lib/velum-detection.sh"
source "$VELUM_ROOT/lib/os/detect.sh"
source "$VELUM_ROOT/lib/providers/provider-base.sh"

# Dead-man switch
security_check "$0" || exit 1

# ============================================================================
# CONFIGURATION STATE
# ============================================================================

# These variables hold the configuration built through the phases
declare -A CONFIG=(
  # Provider
  [provider]=""

  # Credentials (cleared after auth)
  [username]=""
  [password]=""
  [token]=""

  # Security
  [killswitch]="true"
  [killswitch_lan]="detect"
  [ipv6_disabled]="true"
  [use_provider_dns]="true"

  # Features
  [dip_enabled]="false"
  [dip_token]=""
  [port_forward]="false"

  # Server
  [allow_geo]="false"
  [max_latency]="200"
  [selected_region]=""
  [selected_ip]=""
  [selected_hostname]=""

  # Credential source (Phase 4)
  [credential_source]=""
  [credential_command]=""
)

# Configuration file path (from velum-core.sh)
CONFIG_FILE="$VELUM_CONFIG_FILE"

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

# Load existing configuration if present
load_config() {
  if [[ -f "$CONFIG_FILE" ]]; then
    log_info "Loading existing configuration..."
    # Use safe parser with strict mode - warn but continue if config is corrupt
    if ! safe_load_config "$CONFIG_FILE" --strict --known-keys-only 2>/dev/null; then
      print_warn "Failed to parse existing config; continuing with defaults."
      print_warn "Run 'velum config lint' to diagnose issues."
    fi
  fi
}

# Save configuration to file
save_config() {
  log_info "Saving configuration..."

  # Initialize config directories with proper permissions
  init_config_dirs

  {
    echo "# velum-vpn configuration"
    echo "# Generated: $(date)"
    echo "# Location: $CONFIG_FILE"
    echo ""
    echo "# Provider"
    echo "CONFIG[provider]=\"${CONFIG[provider]}\""
    echo ""
    echo "# Security"
    echo "CONFIG[killswitch]=\"${CONFIG[killswitch]}\""
    echo "CONFIG[killswitch_lan]=\"${CONFIG[killswitch_lan]}\""
    echo "CONFIG[ipv6_disabled]=\"${CONFIG[ipv6_disabled]}\""
    echo "CONFIG[use_provider_dns]=\"${CONFIG[use_provider_dns]}\""
    echo ""
    echo "# Features"
    echo "CONFIG[dip_enabled]=\"${CONFIG[dip_enabled]}\""
    echo "CONFIG[dip_token]=\"${CONFIG[dip_token]}\""
    echo "CONFIG[port_forward]=\"${CONFIG[port_forward]}\""
    echo ""
    echo "# Server"
    echo "CONFIG[allow_geo]=\"${CONFIG[allow_geo]}\""
    echo "CONFIG[max_latency]=\"${CONFIG[max_latency]}\""
    echo "CONFIG[selected_region]=\"${CONFIG[selected_region]}\""
    echo "CONFIG[selected_ip]=\"${CONFIG[selected_ip]}\""
    echo "CONFIG[selected_hostname]=\"${CONFIG[selected_hostname]}\""
    echo ""
    echo "# Credential source (Phase 4)"
    echo "CONFIG[credential_source]=\"${CONFIG[credential_source]}\""
    # Only save credential_command if using command source (avoid storing in plaintext otherwise)
    if [[ "${CONFIG[credential_source]}" == "command" ]]; then
      echo "CONFIG[credential_command]=\"${CONFIG[credential_command]}\""
    fi
  } > "$CONFIG_FILE"

  chmod 600 "$CONFIG_FILE"

  # Fix ownership if running as root via sudo
  # Note: _validate_username is defined in velum-core.sh
  if [[ -n "${SUDO_USER:-}" ]] && _validate_username "$SUDO_USER"; then
    local sudo_uid sudo_gid
    sudo_uid=$(id -u "$SUDO_USER" 2>/dev/null)
    sudo_gid=$(id -g "$SUDO_USER" 2>/dev/null)
    if [[ -n "$sudo_uid" && -n "$sudo_gid" ]]; then
      chown "$sudo_uid:$sudo_gid" "$CONFIG_FILE"
    fi
  fi
}

# ============================================================================
# PHASE 0: PROVIDER SELECTION
# ============================================================================

phase_provider() {
  print_section "PROVIDER SELECTION"

  echo "Available VPN providers:"
  echo

  # List available providers
  local providers=()
  local i=1
  while IFS= read -r p; do
    providers+=("$p")
    local desc=""
    case "$p" in
      pia) desc="Private Internet Access - Port forwarding, Dedicated IP" ;;
      mullvad) desc="Mullvad VPN - Privacy-focused, no account info required" ;;
      ivpn) desc="IVPN - Privacy-focused, open source, audited" ;;
      *) desc="VPN Provider" ;;
    esac
    echo "  $i. ${p^^} - $desc"
    ((i++)) || true
  done < <(list_providers)

  echo

  # Check for existing config
  if [[ -n "${CONFIG[provider]}" ]]; then
    print_info "Current provider: ${CONFIG[provider]^^}"
    if ask_yn "Keep current provider?" "y"; then
      return
    fi
  fi

  # Select provider
  local choice
  if ! read -r -p "Select provider [1-${#providers[@]}]: " choice; then
    echo -e "\n\nCancelled."
    exit 130
  fi

  if [[ "$choice" =~ ^[0-9]+$ ]] && [[ "$choice" -ge 1 ]] && [[ "$choice" -le "${#providers[@]}" ]]; then
    CONFIG[provider]="${providers[$((choice-1))]}"
  else
    CONFIG[provider]="pia"  # Default
  fi

  print_ok "Selected: ${CONFIG[provider]^^}"
  echo
}

# ============================================================================
# PHASE 1: AUTHENTICATION
# ============================================================================

phase_authentication() {
  print_section "PHASE 1: AUTHENTICATION"

  # Load provider
  load_provider "${CONFIG[provider]}" || exit 1
  echo "Provider: $(provider_name)"
  echo

  # Get auth type for this provider
  local auth_type
  auth_type=$(provider_auth_type)

  # For account-based providers (Mullvad, IVPN), handle credential source selection
  if [[ "$auth_type" == "account_number" ]]; then
    local current_source="${CONFIG[credential_source]:-}"

    if [[ -z "$current_source" ]]; then
      # First-time setup - show wizard
      if credential_select_source_interactive "${CONFIG[provider]}"; then
        echo
      else
        # Wizard cancelled or failed - default to prompt mode
        print_info "Using default: prompt for credentials each time."
        CONFIG[credential_source]="prompt"
        CONFIG[credential_command]=""
        echo
      fi
    else
      # Existing config - show current source and offer to change
      local source_desc=""
      case "$current_source" in
        prompt) source_desc="Prompt each time (most secure)" ;;
        vault)  source_desc="Encrypted vault" ;;
        *)      source_desc="$current_source" ;;
      esac

      print_info "Credential source: $source_desc"

      if ask_yn "Change credential source?" "n"; then
        if credential_select_source_interactive "${CONFIG[provider]}"; then
          echo
        fi
      fi
      echo
    fi
  fi

  # Check for existing token in tmpfs (session storage)
  local token_status
  if credential_check_token "${CONFIG[provider]}"; then
    local token
    token=$(credential_get_token "${CONFIG[provider]}")
    if [[ -n "$token" ]]; then
      print_ok "Valid session token found (stored in RAM)."
      # Explain why vault/prompt isn't needed
      if [[ "${CONFIG[credential_source]:-}" == "vault" ]]; then
        print_info "Vault access not needed - session token is still valid."
      fi
      CONFIG[token]="$token"

      if ! ask_yn "Use existing token?" "y"; then
        CONFIG[token]=""
      fi
    fi
  fi

  # Also check legacy disk location for PIA (backward compat)
  if [[ -z "${CONFIG[token]}" && "${CONFIG[provider]}" == "pia" ]]; then
    local legacy_token_file="$VELUM_TOKEN_FILE"
    if check_token_expiry "$legacy_token_file" 2>/dev/null; then
      local token
      token=$(read_token "$legacy_token_file")
      if [[ -n "$token" ]]; then
        print_ok "Valid authentication token found (legacy storage)."
        print_info "Token will be migrated to session storage on next auth."
        CONFIG[token]="$token"

        if ! ask_yn "Use existing token?" "y"; then
          CONFIG[token]=""
        fi
      fi
    fi
  fi

  # Need to authenticate?
  if [[ -z "${CONFIG[token]}" ]]; then
    case "$auth_type" in
      username_password)
        _auth_username_password
        ;;
      account_number)
        _auth_account_number
        ;;
      *)
        print_error "Unknown authentication type: $auth_type"
        exit 1
        ;;
    esac
  fi

  echo
}

# Username/password authentication (PIA style)
_auth_username_password() {
  local creds_file
  creds_file="$(os_get_home)/.${CONFIG[provider]}_credentials"

  # Try to load credentials from file
  if [[ -f "$creds_file" ]]; then
    print_info "Found credentials file: $creds_file"
    CONFIG[username]=$(sed -n '1p' "$creds_file" 2>/dev/null || echo "")
    CONFIG[password]=$(sed -n '2p' "$creds_file" 2>/dev/null || echo "")
  fi

  # Prompt for credentials if not loaded
  if [[ -z "${CONFIG[username]}" ]]; then
    local prompt="Username"
    [[ "${CONFIG[provider]}" == "pia" ]] && prompt="PIA username (p#######)"
    CONFIG[username]=$(ask_input "$prompt")
  fi

  if [[ -z "${CONFIG[password]}" ]]; then
    CONFIG[password]=$(ask_password "Password")
  fi

  # Authenticate
  local auth_result
  if auth_result=$(provider_authenticate "${CONFIG[username]}" "${CONFIG[password]}"); then
    CONFIG[token]=$(echo "$auth_result" | jq -r '.token // .access_token')
    local expiry
    expiry=$(echo "$auth_result" | jq -r '.expires_at // .expiry // "unknown"')
    print_ok "Authentication successful!"
    [[ "$expiry" != "unknown" && "$expiry" != "null" ]] && echo "Token expires: $expiry"
  else
    print_error "Authentication failed. Please check your credentials."
    exit 1
  fi

  # Clear credentials from memory - use unset to remove from shell memory
  # Setting to "" leaves the variable allocated; unset deallocates it
  unset 'CONFIG[username]' 'CONFIG[password]'
}

# Account number authentication (Mullvad style)
_auth_account_number() {
  local provider="${CONFIG[provider]}"
  local max_attempts=3
  local attempt=0

  # Get credential from configured source (prompt or vault)
  # During initial config, default to prompt if not configured
  local cred_source="${CONFIG[credential_source]:-prompt}"
  local cred_command="${CONFIG[credential_command]:-}"

  # Retry loop for vault password failures
  while [[ $attempt -lt $max_attempts ]]; do
    attempt=$((attempt + 1))

    if CONFIG[username]=$(credential_get_from_source "$provider" "$cred_source" "$cred_command"); then
      # Got credential successfully
      if [[ -n "${CONFIG[username]:-}" ]]; then
        break
      fi
    fi

    # Failed to get credential
    if [[ $attempt -lt $max_attempts ]]; then
      if [[ "$cred_source" == "vault" ]]; then
        print_warn "Wrong password or no credential stored. Try again. (attempt $attempt/$max_attempts)"
      else
        print_warn "Failed to get credential. Try again. (attempt $attempt/$max_attempts)"
      fi
    else
      print_error "Failed to get account credential after $max_attempts attempts."
      exit 1
    fi
  done

  if [[ -z "${CONFIG[username]:-}" ]]; then
    print_error "Account credential is required for authentication."
    exit 1
  fi

  # Authenticate with provider API
  local auth_result
  if auth_result=$(provider_authenticate "${CONFIG[username]}" ""); then
    CONFIG[token]=$(echo "$auth_result" | jq -r '.access_token // .token')
    local expiry
    expiry=$(echo "$auth_result" | jq -r '.expires_at // .expiry // "unknown"')
    print_ok "Authentication successful!"
    [[ "$expiry" != "unknown" && "$expiry" != "null" ]] && echo "Token expires: $expiry"
  else
    print_error "Authentication failed. Please check your account credential."
    exit 1
  fi

  # Clear account credential from memory - use unset to fully remove
  unset 'CONFIG[username]'
}

# ============================================================================
# PHASE 2: SECURITY PROFILE
# ============================================================================

phase_security() {
  print_section "PHASE 2: SECURITY PROFILE"

  # Explain kill switch
  echo "The kill switch blocks ALL internet traffic if the VPN drops,"
  echo "preventing your real IP from being exposed."
  echo
  echo "When enabled, the kill switch will also:"
  echo "  - Block IPv6 traffic at the firewall level"
  echo "  - Disable IPv6 on network interfaces"
  echo "  - Default to using $(provider_name)'s DNS servers"
  echo

  # Kill switch is the PRIMARY security decision
  if ask_yn "Enable kill switch?" "y"; then
    CONFIG[killswitch]="true"
    CONFIG[ipv6_disabled]="true"  # Auto-set when kill switch enabled

    print_ok "Kill switch will be enabled."
    echo "  IPv6 protection: Enabled (interface + firewall)"
    echo

    # LAN policy (only asked if kill switch enabled)
    echo "LAN Policy: Choose how to handle local network traffic."
    echo "  block  - Block all LAN traffic (most secure)"
    echo "  detect - Auto-detect and allow your local subnet"
    echo "  CIDR   - Specify a custom subnet (e.g., 10.0.1.0/24)"
    echo

    local lan_choice
    lan_choice=$(ask_input "LAN policy" "detect")
    CONFIG[killswitch_lan]="$lan_choice"

    if [[ "$lan_choice" == "detect" ]]; then
      local detected
      detected=$(os_detect_subnet 2>/dev/null || echo "")
      if [[ -n "$detected" ]]; then
        echo "Detected local subnet: $detected"
      else
        print_warn "Could not detect local subnet. LAN traffic may be blocked."
      fi
    fi

  else
    CONFIG[killswitch]="false"
    print_warn "Kill switch DISABLED - VPN drops may expose your real IP!"
    echo

    # IPv6 asked separately when kill switch is off
    echo "IPv6 can leak your real IP even when VPN is connected."
    if ask_yn "Disable IPv6?" "y"; then
      CONFIG[ipv6_disabled]="true"
    else
      CONFIG[ipv6_disabled]="false"
    fi
  fi

  echo

  # DNS (always asked, but with smart default)
  echo "Using third-party DNS could allow DNS monitoring."
  local dns_default="y"
  if [[ "${CONFIG[killswitch]}" == "true" ]]; then
    echo "(Recommended: Yes, since kill switch is enabled)"
  fi

  if ask_yn "Use $(provider_name) DNS servers?" "$dns_default"; then
    CONFIG[use_provider_dns]="true"
  else
    CONFIG[use_provider_dns]="false"
    print_warn "Using system DNS - DNS queries may be visible to ISP."
  fi

  echo
}

# ============================================================================
# PHASE 3: CONNECTION FEATURES
# ============================================================================

phase_features() {
  print_section "PHASE 3: CONNECTION FEATURES"

  # Check if provider has any optional features
  local has_dip=false
  local has_pf=false
  provider_supports_dip && has_dip=true
  provider_supports_pf && has_pf=true

  if [[ "$has_dip" != "true" && "$has_pf" != "true" ]]; then
    echo "$(provider_name) does not offer Dedicated IP or port forwarding."
    echo "No optional features to configure."
    echo
    return
  fi

  # Dedicated IP
  if provider_supports_dip; then
    echo "Dedicated IP provides a static IP address for your connection."
    if ask_yn "Use Dedicated IP?" "n"; then
      CONFIG[dip_enabled]="true"

      local dip_token
      dip_token=$(ask_input "DIP token")

      # Validate DIP token
      if provider_get_dip "$dip_token" >/dev/null 2>&1; then
        CONFIG[dip_token]="$dip_token"
        print_ok "DIP token validated successfully!"

        # DIP may not support port forwarding
        local dip_info
        dip_info=$(provider_get_dip "$dip_token")
        local dip_pf
        dip_pf=$(echo "$dip_info" | jq -r '.port_forward // false')
        if [[ "$dip_pf" != "true" ]]; then
          print_warn "Note: Your DIP does not support port forwarding."
          CONFIG[port_forward]="false"
        fi
      else
        print_error "Invalid DIP token. Continuing without DIP."
        CONFIG[dip_enabled]="false"
      fi
    fi
    echo
  fi

  # Port forwarding (skip if DIP doesn't support it)
  if [[ "${CONFIG[dip_enabled]}" != "true" ]] || [[ -z "${CONFIG[dip_token]}" ]]; then
    if provider_supports_pf; then
      echo "Port forwarding allows incoming connections to your device."
      echo "Note: Not available on US servers."
      if ask_yn "Enable port forwarding?" "n"; then
        CONFIG[port_forward]="true"
      else
        CONFIG[port_forward]="false"
      fi
      echo
    fi
  fi
}

# ============================================================================
# PHASE 4: SERVER SELECTION
# ============================================================================

# Sanitize untrusted API strings for safe display and storage.
# Strips control characters (ANSI escapes, etc.) and replaces field delimiters.
_sanitize_field() {
  local value="$1"
  # Remove control characters (0x00-0x1F, 0x7F) to prevent terminal injection
  # Replace pipe delimiter to prevent field parsing issues
  value=$(printf '%s' "$value" | tr -d '[:cntrl:]' | tr '|' '/')
  printf '%s' "$value"
}

# Helper: Extract server data by provider format
# Output format: id|name|ip|hostname|country_code|host_provider|owned
# Note: country_code is used for alliance/privacy lookups; name contains display name
_extract_server_data() {
  local server="$1"
  local provider="$2"
  local id name ip hostname country_code host_provider owned

  case "$provider" in
    mullvad)
      id=$(echo "$server" | jq -r '.hostname')
      name=$(echo "$server" | jq -r '"\(.country_name) - \(.city_name)"')
      ip=$(echo "$server" | jq -r '.ipv4_addr_in // empty')
      hostname="$id"
      # Use country_code (e.g., "US") for alliance/privacy lookups, not country_name
      country_code=$(echo "$server" | jq -r '.country_code // empty' | tr '[:lower:]' '[:upper:]')
      # Normalize host_provider: trim whitespace (preserve internal spaces), lowercase for matching
      host_provider=$(echo "$server" | jq -r '.provider // "unknown"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | tr '[:upper:]' '[:lower:]')
      owned=$(echo "$server" | jq -r '.owned // false')
      ;;
    ivpn)
      id=$(echo "$server" | jq -r '.hosts[0].hostname')
      name=$(echo "$server" | jq -r '"\(.country) - \(.city)"')
      ip=$(echo "$server" | jq -r '.hosts[0].host // empty')
      hostname="$id"
      # IVPN uses country name; extract country code if available, else use name
      country_code=$(echo "$server" | jq -r '.country_code // empty' | tr '[:lower:]' '[:upper:]')
      if [[ -z "$country_code" ]]; then
        # Fallback: use country name (less reliable for lookups)
        country_code=$(echo "$server" | jq -r '.country // empty')
      fi
      # IVPN doesn't expose provider/owned - mark as unknown
      host_provider="unknown"
      owned="unknown"
      ;;
    *)  # PIA
      id=$(echo "$server" | jq -r '.id')
      name=$(echo "$server" | jq -r '.name')
      ip=$(echo "$server" | jq -r '.servers.wg[0].ip // empty')
      hostname=$(echo "$server" | jq -r '.servers.wg[0].cn // empty')
      # PIA names are like "US New York" - extract country code prefix
      country_code="${name%% *}"
      # PIA doesn't expose provider/owned - mark as unknown
      host_provider="unknown"
      owned="unknown"
      ;;
  esac

  # Sanitize user-facing fields to prevent control char injection and delimiter issues
  name=$(_sanitize_field "$name")
  host_provider=$(_sanitize_field "$host_provider")

  # Output: id|name|ip|hostname|country_code|host_provider|owned
  echo "${id}|${name}|${ip}|${hostname}|${country_code}|${host_provider}|${owned}"
}

# Helper: Check detection status for servers before display
# Usage: _check_server_detection max_check entry1 entry2 ...
# Entry format: score|det_sort|owned_sort|latency|id|name|ip|hostname|country_code|host_provider|owned|sec_detail
_check_server_detection() {
  local max_check="${1:-30}"
  shift
  local entries=("$@")

  # Collect unique IPs to check
  local ips_to_check=()
  local checked_ips=""
  local i=0

  for entry in "${entries[@]}"; do
    [[ $i -ge $max_check ]] && break

    local ip
    ip=$(echo "$entry" | cut -d'|' -f7)  # IP is field 7 in new format
    [[ -z "$ip" || "$ip" == "null" ]] && continue

    # Skip if already in our list or cached
    if [[ "$checked_ips" != *"|$ip|"* ]]; then
      local cached
      cached=$(get_cached_detection "$ip" 2>/dev/null || true)
      if [[ -z "$cached" ]]; then
        ips_to_check+=("$ip")
      fi
      checked_ips="${checked_ips}|${ip}|"
    fi
    ((i++)) || true
  done

  local total=${#ips_to_check[@]}
  if [[ $total -eq 0 ]]; then
    echo "Detection results cached for all servers."
    return 0
  fi

  echo "Checking detection status for $total unique IPs..."
  echo -n "Progress: "

  local count=0
  for ip in "${ips_to_check[@]}"; do
    # Run check (this caches the result)
    check_detection "$ip" >/dev/null 2>&1
    ((count++)) || true

    # Show progress
    local pct=$((count * 100 / total))
    echo -ne "\rProgress: ${count}/${total} (${pct}%) "
  done

  echo -e "\rProgress: Complete!              "
}

# Helper: Get numeric recommendation score from server entry for sorting
# Returns: security score (0-6) and detail string
# Note: Detection status is display-only and does NOT affect quality score.
_compute_security_score() {
  local entry="$1"
  local latency id name ip hostname country_code host_provider owned
  IFS='|' read -r latency id name ip hostname country_code host_provider owned <<< "$entry"

  local alliance_score=0
  local privacy_bonus=0
  local ownership_bonus=0
  local unknown_penalty=0
  local mismatch_penalty=0
  local latency_penalty=0

  # Alliance scoring (0-3)
  local alliance
  alliance=$(get_alliance "$country_code")
  case "$alliance" in
    "Blind")   alliance_score=3 ;;
    "14-Eyes") alliance_score=2 ;;
    "9-Eyes")  alliance_score=1 ;;
    "5-Eyes"|"Unknown") alliance_score=0 ;;
  esac

  # Privacy bonus (0-1) to avoid double-counting country
  local privacy_rating
  privacy_rating=$(get_privacy "$country_code")
  if [[ "$privacy_rating" -ge 4 ]]; then
    privacy_bonus=1
  fi

  # Ownership / mismatch penalties
  if [[ "$owned" == "true" ]]; then
    ownership_bonus=1
  elif [[ "$owned" == "unknown" ]]; then
    unknown_penalty=-1
  else
    local mismatch
    mismatch=$(check_jurisdiction_mismatch "$country_code" "$host_provider" "$owned")
    case "$mismatch" in
      "5-EYES-HOSTED") mismatch_penalty=-3 ;;
      "JURISDICTION-MISMATCH") mismatch_penalty=-2 ;;
      "UNKNOWN") mismatch_penalty=-1 ;;
      *) mismatch_penalty=0 ;;
    esac
  fi

  # Small latency penalty for slow servers
  if [[ "$latency" =~ ^[0-9]+$ ]] && [[ "$latency" -gt 200 ]]; then
    latency_penalty=-1
  fi

  local total=$((alliance_score + privacy_bonus + ownership_bonus + unknown_penalty + mismatch_penalty + latency_penalty))
  [[ $total -lt 0 ]] && total=0
  [[ $total -gt 6 ]] && total=6

  local detail="A${alliance_score}P${privacy_bonus}O${ownership_bonus}U${unknown_penalty}M${mismatch_penalty}L${latency_penalty}=${total}"
  echo "${total}|${detail}"
}

# Map security score (0-6) to recommendation tier (0-3)
_security_score_to_rec() {
  local score="${1:-0}"
  if [[ "$score" -ge 4 ]]; then
    echo "3"
  elif [[ "$score" -ge 2 ]]; then
    echo "2"
  elif [[ "$score" -ge 1 ]]; then
    echo "1"
  else
    echo "0"
  fi
}

# Detection sort value (for optional deprioritization)
_detection_sort_value() {
  local ip="$1"
  local status
  status=$(get_cached_detection "$ip" 2>/dev/null || echo "")
  case "$status" in
    "clean") echo "0" ;;
    "partial") echo "1" ;;
    "flagged") echo "2" ;;
    *) echo "1" ;;  # unknown treated as partial for ordering
  esac
}

# Helper: Display enhanced server table
# Usage: _display_server_table max_display sort_mode entry1 entry2 entry3 ...
# sort_mode: "quality" or "speed"
# Entry format: score|det_sort|owned_sort|latency|id|name|ip|hostname|country_code|host_provider|owned|sec_detail
_display_server_table() {
  local max_display="${1:-30}"
  local sort_mode="${2:-speed}"
  shift 2
  local entries=("$@")

  local sort_desc
  case "$sort_mode" in
    "quality") sort_desc="sorted by security score, then latency" ;;
    "detect")  sort_desc="sorted by detectability, then security" ;;
    *)         sort_desc="sorted by latency" ;;
  esac

  echo
  echo "Server Selection ($sort_desc):"
  echo "──────────────────────────────────────────────────────────────────────────────────────────"
  printf "  %-3s %7s   %-24s %-8s %-5s %-4s %-3s %-18s %s\n" "#" "Latency" "Location" "Alliance" "Priv" "Host" "Det" "Sec" "Rec"
  echo "──────────────────────────────────────────────────────────────────────────────────────────"

  local i=1
  for entry in "${entries[@]}"; do
    [[ $i -gt $max_display ]] && break

    # Parse entry: score|det_sort|owned_sort|latency|id|name|ip|hostname|country_code|host_provider|owned|sec_detail
    local score det_sort owned_sort latency id name ip hostname country_code host_provider owned sec_detail
    IFS='|' read -r score det_sort owned_sort latency id name ip hostname country_code host_provider owned sec_detail <<< "$entry"

    # Get jurisdiction info
    local alliance privacy_rating privacy_bar
    alliance=$(get_alliance "$country_code")
    privacy_rating=$(get_privacy "$country_code")
    privacy_bar=$(privacy_to_bar "$privacy_rating")

    # Get host provider status symbol
    local host_sym
    host_sym=$(provider_to_symbol "$host_provider" "$owned" "$country_code")

    # Get detection status (from cache or "…" if not yet checked)
    local detection detection_sym
    detection=$(get_cached_detection "$ip")
    if [[ -n "$detection" ]]; then
      detection_sym=$(detection_to_symbol "$detection")
    else
      detection_sym="…"
    fi

    # Use pre-computed security score for recommendation tier
    local rec rec_stars
    rec=$(_security_score_to_rec "$score")
    rec_stars=$(recommendation_to_stars "$rec")

    # Format latency
    local latency_fmt
    if [[ "$latency" =~ ^[0-9]+$ ]]; then
      latency_fmt="${latency}ms"
    else
      latency_fmt="${latency}"
    fi

    # Truncate location if needed
    local loc_display="${name}"
    [[ ${#loc_display} -gt 24 ]] && loc_display="${loc_display:0:21}..."

    # Color entire row based on recommendation tier
    local row_color=""
    local reset="${C_RESET:-}"
    case "$rec" in
      3) row_color="${C_GREEN:-}" ;;
      2) row_color="" ;;
      1) row_color="${C_YELLOW:-}" ;;
      0) row_color="${C_RED:-}" ;;
    esac

    printf "%s%3d. %7s   %-24s %-8s %s  %s    %s   %-18s %s%s\n" \
      "$row_color" "$i" "$latency_fmt" "$loc_display" "$alliance" "$privacy_bar" "$host_sym" "$detection_sym" "$sec_detail" "$rec_stars" "$reset"

    ((i++)) || true
  done

  echo "──────────────────────────────────────────────────────────────────────────────────────────"
  echo
  print_jurisdiction_legend
  echo
}

phase_server() {
  print_section "PHASE 4: SERVER SELECTION"

  # Skip if DIP is configured (DIP has fixed server)
  if [[ "${CONFIG[dip_enabled]}" == "true" ]] && [[ -n "${CONFIG[dip_token]}" ]]; then
    local dip_info
    dip_info=$(provider_get_dip "${CONFIG[dip_token]}")
    CONFIG[selected_ip]=$(echo "$dip_info" | jq -r '.ip')
    CONFIG[selected_hostname]=$(echo "$dip_info" | jq -r '.cn')
    CONFIG[selected_region]="dip"
    print_info "Using Dedicated IP server: ${CONFIG[selected_ip]}"
    return
  fi

  # Geo servers (PIA-specific feature)
  if [[ "${CONFIG[provider]}" == "pia" ]]; then
    echo "Geo-located servers appear to be in a different country than"
    echo "their actual physical location (for censorship bypass)."
    if ask_yn "Allow geo-located servers?" "n"; then
      CONFIG[allow_geo]="true"
    else
      CONFIG[allow_geo]="false"
    fi
    echo
  fi

  # Server priority selection (manual only - no auto mode per SEC-001)
  echo "Server priority:"
  echo "  1) Quality       (jurisdiction + ownership; detection optional)"
  echo "  2) Speed         (lowest latency first)"
  echo "  3) Detectability (clean IPs first, then security)"
  echo

  local priority_choice
  while true; do
    if ! read -r -p "Select [1-3, default=1]: " priority_choice; then
      echo -e "\n\nCancelled."
      exit 130
    fi
    # Default to Quality if empty
    [[ -z "$priority_choice" ]] && priority_choice="1"
    if [[ "$priority_choice" =~ ^[123]$ ]]; then
      break
    fi
    print_error "Invalid selection."
  done

  local sort_by_quality=false
  [[ "$priority_choice" == "1" ]] && sort_by_quality=true
  local sort_by_detect=false
  [[ "$priority_choice" == "3" ]] && sort_by_detect=true

  # Optional detection deprioritization (quality mode only)
  local deprioritize_detection=false
  if [[ "$sort_by_quality" == "true" && "$sort_by_detect" == "false" ]]; then
    if ask_yn "Deprioritize detected VPN IPs in quality sort?" "n"; then
      deprioritize_detection=true
    fi
    echo
  fi

  # Latency threshold (0 = show all)
  local threshold default_threshold
  default_threshold="${CONFIG[max_latency]:-200}"
  if [[ "$default_threshold" =~ ^0\.[0-9]+$ ]]; then
    default_threshold=$(awk "BEGIN {printf \"%.0f\", $default_threshold * 1000}")
  fi
  while true; do
    threshold=$(ask_input "Maximum latency in ms (0 = show all)" "$default_threshold")
    if [[ -z "$threshold" ]]; then
      threshold="$default_threshold"
    fi
    if [[ "$threshold" =~ ^0\.[0-9]+$ ]]; then
      threshold=$(awk "BEGIN {printf \"%.0f\", $threshold * 1000}")
    fi
    if [[ "$threshold" =~ ^[0-9]+$ ]]; then
      break
    fi
    print_error "Invalid latency value. Use a number in milliseconds (e.g., 200) or 0 for all."
  done
  CONFIG[max_latency]="$threshold"

  # Get and display server list
  echo

  local filters=""
  [[ "${CONFIG[allow_geo]}" != "true" ]] && filters="--geo false"
  [[ "${CONFIG[port_forward]}" == "true" ]] && filters="$filters --port-forward true"

  # Fetch server list with visible progress (API call can take a few seconds)
  printf "  Fetching server list from %s..." "$(provider_name)"
  local servers
  local spinner_pid=""
  (while true; do printf "."; sleep 0.2; done) & spinner_pid=$!
  # shellcheck disable=SC2086
  servers=$(provider_filter_servers $filters)
  if [[ -n "$spinner_pid" ]]; then
    kill "$spinner_pid" 2>/dev/null || true
    wait "$spinner_pid" 2>/dev/null || true
  fi
  printf " done.\n"
  echo

    # Preparing server list (show progress + spinner)
    echo -n "  Preparing server list..."
    local prep_spinner_pid=""
    (while true; do printf "."; sleep 0.2; done) & prep_spinner_pid=$!

    # =========================================================================
    # PARALLEL LATENCY TESTING
    # =========================================================================
    #
    # OPTIMIZATION NOTE: This uses parallel ping testing to reduce wait time.
    # Sequential testing of all servers @ 2-3s each would be very slow.
    # Parallel testing with 15 concurrent pings completes much faster.
    #
    # FUTURE OPTIMIZATION: fping (https://fping.org) would be ideal here -
    # it can ping hundreds of hosts in a single syscall. Unfortunately,
    # fping has been locked in academic purgatory since Roland Schemers
    # wrote it at Stanford in 1992. Perhaps someday someone will write a
    # modern, permissively-licensed multi-ping tool. Until then, we make
    # do with parallel bash pings.
    #
    # TODO: Pre-filter servers by region before latency testing. If user
    # is in North America, no need to test 30 Australian servers.
    # =========================================================================

    # First pass: collect server metadata without testing (NO arbitrary limit)
    local server_info=()
    local prep_count=0
    local prep_total=0
    prep_total=$(echo "$servers" | jq -r 'length' 2>/dev/null || echo 0)

    while IFS= read -r server; do
      local extracted id name ip hostname country_code host_provider owned

      extracted=$(_extract_server_data "$server" "${CONFIG[provider]}")
      IFS='|' read -r id name ip hostname country_code host_provider owned <<< "$extracted"

      [[ -z "$ip" || "$ip" == "null" ]] && continue

      # Store server info for parallel testing
      # Format: id|name|ip|hostname|country_code|host_provider|owned
      server_info+=("${id}|${name}|${ip}|${hostname}|${country_code}|${host_provider}|${owned}")
      prep_count=$((prep_count + 1))
      if [[ $((prep_count % 50)) -eq 0 ]]; then
        if [[ "$prep_total" -gt 0 ]]; then
          printf "\r  Preparing server list... %d/%d" "$prep_count" "$prep_total"
        else
          printf "\r  Preparing server list... %d" "$prep_count"
        fi
      fi
    done < <(echo "$servers" | jq -c '.[]')

    local total_servers=${#server_info[@]}
    if [[ -n "$prep_spinner_pid" ]]; then
      kill "$prep_spinner_pid" 2>/dev/null || true
      wait "$prep_spinner_pid" 2>/dev/null || true
    fi
    if [[ "$prep_total" -gt 0 ]]; then
      printf "\r  Preparing server list... %d/%d\n" "$prep_count" "$prep_total"
    else
      printf "\r  Preparing server list... %d\n" "$prep_count"
    fi
    echo "  Prepared $total_servers servers."
    echo

    local ping_count="${VELUM_PING_COUNT:-1}"
    local ping_timeout="${VELUM_PING_TIMEOUT:-1}"
    echo "  Testing latency to $total_servers servers (ping count=${ping_count}, timeout=${ping_timeout}s)..."

    # Create temp directory for parallel results
    local results_dir
    results_dir=$(mktemp -d) || { echo "ERROR: mktemp -d failed"; exit 1; }

    # Parallel latency testing
    # Note: Using job array approach for bash 4.x compatibility
    # (wait -n is bash 4.3+ and unreliable across distributions)
    local max_concurrent=15
    local tested=0
    local pids=()
    local id name ip hostname country_code host_provider owned
    local idx=0

    for info in "${server_info[@]}"; do
      IFS='|' read -r id name ip hostname country_code host_provider owned <<< "$info"
      idx=$((idx + 1))

      # Background ping job - writes result to temp file
      # Note: Subshell uses explicit bash to avoid set -e inheritance issues
      bash -c '
        ip="$1"
        results_dir="$2"
        idx="$3"
        id="$4"
        name="$5"
        hostname="$6"
        country_code="$7"
        host_provider="$8"
        owned="$9"
        ping_count="${10}"
        ping_timeout="${11}"

        latency=""
        if [[ "$(uname)" == "Darwin" ]]; then
          latency=$(ping -c "$ping_count" -t "$ping_timeout" "$ip" 2>/dev/null | grep "time=" | sed "s/.*time=\([0-9.]*\).*/\1/")
        else
          latency=$(ping -c "$ping_count" -W "$ping_timeout" "$ip" 2>/dev/null | grep "time=" | sed "s/.*time=\([0-9.]*\).*/\1/")
        fi

        if [[ -n "$latency" && "$latency" =~ ^[0-9.]+$ ]]; then
          latency=$(printf "%.0f" "$latency" 2>/dev/null || echo "9999")
        else
          latency="9999"
        fi

        # Write result to temp file (atomic via rename)
        echo "${latency}|${id}|${name}|${ip}|${hostname}|${country_code}|${host_provider}|${owned}" > "${results_dir}/${idx}.tmp"
        mv "${results_dir}/${idx}.tmp" "${results_dir}/${idx}.result"
      ' _ "$ip" "$results_dir" "$idx" "$id" "$name" "$hostname" "$country_code" "$host_provider" "$owned" "$ping_count" "$ping_timeout" &

      pids+=($!)
      tested=$((tested + 1))

      # Show progress
      printf "\r  Progress: %d/%d " "$tested" "$total_servers"

      # Wait for a batch if at max concurrency
      if [[ ${#pids[@]} -ge $max_concurrent ]]; then
        # Wait for all current batch to complete
        for pid in "${pids[@]}"; do
          wait "$pid" 2>/dev/null || true
        done
        pids=()
      fi
    done

    # Wait for remaining jobs in the last batch
    for pid in "${pids[@]}"; do
      wait "$pid" 2>/dev/null || true
    done
    printf "\r  Progress: %d/%d - Complete!        \n" "$total_servers" "$total_servers"

    # Collect all results (no filter yet)
    local all_server_data=()
    for result_file in "${results_dir}"/*.result; do
      [[ -f "$result_file" ]] || continue

      local result
      result=$(cat "$result_file")
      local latency
      latency=$(echo "$result" | cut -d'|' -f1)

      # Include servers with valid latency (even 9999 = timeout)
      if [[ "$latency" =~ ^[0-9]+$ ]]; then
        all_server_data+=("$result")
      fi
    done

    # Cleanup temp directory
    rm -rf "$results_dir"

    if [[ ${#all_server_data[@]} -eq 0 ]]; then
      print_error "No servers responded to ping. Check your network connection."
      exit 1
    fi

    echo
    echo "Received responses from ${#all_server_data[@]} servers."
    echo

    # Optional debug: latency distribution and top servers
    if [[ "${VELUM_DEBUG_LATENCY:-0}" == "1" ]]; then
      local total_count=${#all_server_data[@]}
      local timeout_count=0
      local under_200=0
      for entry in "${all_server_data[@]}"; do
        local latency
        latency=$(echo "$entry" | cut -d'|' -f1)
        if [[ "$latency" == "9999" ]]; then
          timeout_count=$((timeout_count + 1))
        elif [[ "$latency" =~ ^[0-9]+$ && "$latency" -le 200 ]]; then
          under_200=$((under_200 + 1))
        fi
      done

      echo "DEBUG: latency summary"
      echo "  total tested:   $total_count"
      echo "  <= 200ms:       $under_200"
      echo "  timeouts:       $timeout_count"
      echo

      echo "DEBUG: top 100 fastest (latency | location | hostname)"
      printf '%s\n' "${all_server_data[@]}" | sort -t'|' -k1,1n | head -100 | \
        while IFS='|' read -r latency id name ip hostname country_code host_provider owned; do
          printf "  %4sms | %-26s | %s\n" "$latency" "$name" "$hostname"
        done
      echo

      echo "DEBUG: Zurich entries (latency | location | hostname)"
      printf '%s\n' "${all_server_data[@]}" | \
        while IFS='|' read -r latency id name ip hostname country_code host_provider owned; do
          if [[ "$name" == *"Zurich"* ]] || [[ "$hostname" == *"zrh"* ]] || [[ "$country_code" == "CH" ]]; then
            printf "  %4sms | %-26s | %s\n" "$latency" "$name" "$hostname"
          fi
        done
      echo
    fi

    # Apply latency threshold (0 = show all)
    local filtered_server_data=()
    if [[ "$threshold" -gt 0 ]]; then
      for entry in "${all_server_data[@]}"; do
        local latency
        latency=$(echo "$entry" | cut -d'|' -f1)
        if [[ "$latency" -le "$threshold" ]]; then
          filtered_server_data+=("$entry")
        fi
      done
      echo "Latency filter: <= ${threshold}ms → ${#filtered_server_data[@]} of ${#all_server_data[@]} servers."
      if [[ ${#filtered_server_data[@]} -eq 0 ]]; then
        print_warn "No servers met the latency threshold. Showing all servers instead."
        filtered_server_data=("${all_server_data[@]}")
      elif [[ ${#filtered_server_data[@]} -lt 20 && "${VELUM_STRICT_LATENCY:-0}" != "1" ]]; then
        print_warn "Only ${#filtered_server_data[@]} servers met the latency threshold."
        print_warn "ICMP latency can be unreliable or rate-limited."
        print_info "Showing all servers instead (set VELUM_STRICT_LATENCY=1 to enforce)."
        filtered_server_data=("${all_server_data[@]}")
      else
        echo "Tip: Enter 0 at the latency prompt to show all servers."
      fi
      echo
    else
      filtered_server_data=("${all_server_data[@]}")
    fi

    # =========================================================================
    # PRE-COMPUTE SECURITY SCORES (PERF-001)
    # =========================================================================
    # Compute scores ONCE here, not on every sort. New format:
    # score|det_sort|owned_sort|latency|id|name|ip|hostname|country_code|host_provider|owned|sec_detail
    # owned_sort: 1=owned, 2=unknown, 3=rented (SEC-004)
    echo -n "Pre-computing security scores..."
    local scored_server_data=()
    for entry in "${filtered_server_data[@]}"; do
      local latency id name ip hostname country_code host_provider owned
      IFS='|' read -r latency id name ip hostname country_code host_provider owned <<< "$entry"

      # Calculate security score + detail
      local score_detail score sec_detail
      score_detail=$(_compute_security_score "$entry")
      score=$(echo "$score_detail" | cut -d'|' -f1)
      sec_detail=$(echo "$score_detail" | cut -d'|' -f2)

      # Calculate owned_sort for tie-breaking (SEC-004)
      local owned_sort
      case "$owned" in
        true)    owned_sort=1 ;;
        unknown) owned_sort=2 ;;
        *)       owned_sort=3 ;;  # false or anything else = rented
      esac

      # det_sort defaults to 0 (ignored unless deprioritization enabled)
      local det_sort=0

      # New format: score|det_sort|owned_sort|latency|id|name|ip|hostname|country_code|host_provider|owned|sec_detail
      scored_server_data+=("${score}|${det_sort}|${owned_sort}|${entry}|${sec_detail}")
    done
    echo " done."

    # Sort based on priority mode (instant with pre-computed scores)
    local sorted_data=()
    if [[ "$sort_by_quality" == "true" ]]; then
      # Sort by: score (desc), det_sort (asc), owned_sort (asc), latency (asc)
      IFS=$'\n' sorted_data=($(printf '%s\n' "${scored_server_data[@]}" | sort -t'|' -k1,1rn -k2,2n -k3,3n -k4,4n))
      unset IFS
    elif [[ "$sort_by_detect" == "true" ]]; then
      # Sort by: det_sort (asc), score (desc), owned_sort (asc), latency (asc)
      IFS=$'\n' sorted_data=($(printf '%s\n' "${scored_server_data[@]}" | sort -t'|' -k2,2n -k1,1rn -k3,3n -k4,4n))
      unset IFS
    else
      # Sort by latency only (field 4 in new format)
      IFS=$'\n' sorted_data=($(printf '%s\n' "${scored_server_data[@]}" | sort -t'|' -k4,4n))
      unset IFS
    fi

    # Check detection status for top servers AFTER sorting (UX-002)
    local detection_check_count=100
    [[ ${#sorted_data[@]} -lt $detection_check_count ]] && detection_check_count=${#sorted_data[@]}
    _check_server_detection "$detection_check_count" "${sorted_data[@]}"
    echo

    # Optional detection deprioritization (quality mode only)
    if [[ "$sort_by_quality" == "true" && "$deprioritize_detection" == "true" ]]; then
      local updated_scored=()
      for entry in "${scored_server_data[@]}"; do
        local score det_sort owned_sort latency id name ip hostname country_code host_provider owned sec_detail
        IFS='|' read -r score det_sort owned_sort latency id name ip hostname country_code host_provider owned sec_detail <<< "$entry"
        det_sort=$(_detection_sort_value "$ip")
        updated_scored+=("${score}|${det_sort}|${owned_sort}|${latency}|${id}|${name}|${ip}|${hostname}|${country_code}|${host_provider}|${owned}|${sec_detail}")
      done
      scored_server_data=("${updated_scored[@]}")
      IFS=$'\n' sorted_data=($(printf '%s\n' "${scored_server_data[@]}" | sort -t'|' -k1,1rn -k2,2n -k3,3n -k4,4n))
      unset IFS
    fi

    # Detectability mode: update det_sort and re-sort
    if [[ "$sort_by_detect" == "true" ]]; then
      local updated_scored=()
      for entry in "${scored_server_data[@]}"; do
        local score det_sort owned_sort latency id name ip hostname country_code host_provider owned sec_detail
        IFS='|' read -r score det_sort owned_sort latency id name ip hostname country_code host_provider owned sec_detail <<< "$entry"
        det_sort=$(_detection_sort_value "$ip")
        updated_scored+=("${score}|${det_sort}|${owned_sort}|${latency}|${id}|${name}|${ip}|${hostname}|${country_code}|${host_provider}|${owned}|${sec_detail}")
      done
      scored_server_data=("${updated_scored[@]}")
      IFS=$'\n' sorted_data=($(printf '%s\n' "${scored_server_data[@]}" | sort -t'|' -k2,2n -k1,1rn -k3,3n -k4,4n))
      unset IFS
    fi

    # =========================================================================
    # SERVER SELECTION LOOP (allows re-filtering without re-pinging)
    # =========================================================================
    local max_display=50  # Display limit (not test limit)
    local current_sort_mode
    if [[ "$sort_by_quality" == "true" ]]; then
      current_sort_mode="quality"
    elif [[ "$sort_by_detect" == "true" ]]; then
      current_sort_mode="detect"
    else
      current_sort_mode="speed"
    fi

    while true; do
      # Apply display limit
      local display_data=("${sorted_data[@]:0:$max_display}")
      local total_available=${#sorted_data[@]}

      echo
      echo "Showing ${#display_data[@]} of $total_available servers."

      # Display enhanced table with detection results
      _display_server_table "${#display_data[@]}" "$current_sort_mode" "${display_data[@]}"

      # Build selection arrays for current display
      # Entry format: score|det_sort|owned_sort|latency|id|name|ip|hostname|country_code|host_provider|owned|sec_detail
      local region_ids=()
      local region_names=()
      local region_ips=()
      local region_hostnames=()

      local i=1
      for entry in "${display_data[@]}"; do
        local score det_sort owned_sort latency id name ip hostname country_code host_provider owned sec_detail
        IFS='|' read -r score det_sort owned_sort latency id name ip hostname country_code host_provider owned sec_detail <<< "$entry"
        region_ids+=("$id")
        region_names+=("$name")
        region_ips+=("$ip")
        region_hostnames+=("$hostname")
        ((i++)) || true
      done

      # Selection prompt with options
      echo
      echo "Options: [1-${#display_data[@]}] select server, [m] show more, [q] quality sort, [s] speed sort, [d] detectability sort"
      local choice
      if ! read -r -p "Selection: " choice; then
        echo -e "\n\nCancelled."
        exit 130
      fi

      case "$choice" in
        m|M)
          max_display=$((max_display + 50))
          [[ $max_display -gt $total_available ]] && max_display=$total_available
          # Check detection for newly visible servers (uses cache, only checks uncached)
          local check_count=$((max_display + 50))
          [[ $check_count -gt ${#sorted_data[@]} ]] && check_count=${#sorted_data[@]}
          _check_server_detection "$check_count" "${sorted_data[@]}"
          if [[ "$current_sort_mode" == "quality" && "$deprioritize_detection" == "true" ]]; then
            local updated_scored=()
            for entry in "${scored_server_data[@]}"; do
              local score det_sort owned_sort latency id name ip hostname country_code host_provider owned sec_detail
              IFS='|' read -r score det_sort owned_sort latency id name ip hostname country_code host_provider owned sec_detail <<< "$entry"
              det_sort=$(_detection_sort_value "$ip")
              updated_scored+=("${score}|${det_sort}|${owned_sort}|${latency}|${id}|${name}|${ip}|${hostname}|${country_code}|${host_provider}|${owned}|${sec_detail}")
            done
            scored_server_data=("${updated_scored[@]}")
            IFS=$'\n' sorted_data=($(printf '%s\n' "${scored_server_data[@]}" | sort -t'|' -k1,1rn -k2,2n -k3,3n -k4,4n))
            unset IFS
          fi
          continue
          ;;
        q|Q)
          if [[ "$current_sort_mode" != "quality" ]]; then
            current_sort_mode="quality"
            # Re-sort by quality - instant with pre-computed scores (PERF-001)
            # Sort by: score (desc), det_sort (asc), owned_sort (asc), latency (asc)
            IFS=$'\n' sorted_data=($(printf '%s\n' "${scored_server_data[@]}" | sort -t'|' -k1,1rn -k2,2n -k3,3n -k4,4n))
            unset IFS
            # Check detection for newly visible servers (uses cache, only checks uncached)
            local check_count=$((max_display + 50))
            [[ $check_count -gt ${#sorted_data[@]} ]] && check_count=${#sorted_data[@]}
            _check_server_detection "$check_count" "${sorted_data[@]}"
            if [[ "$deprioritize_detection" == "true" ]]; then
              local updated_scored=()
              for entry in "${scored_server_data[@]}"; do
                local score det_sort owned_sort latency id name ip hostname country_code host_provider owned sec_detail
                IFS='|' read -r score det_sort owned_sort latency id name ip hostname country_code host_provider owned sec_detail <<< "$entry"
                det_sort=$(_detection_sort_value "$ip")
                updated_scored+=("${score}|${det_sort}|${owned_sort}|${latency}|${id}|${name}|${ip}|${hostname}|${country_code}|${host_provider}|${owned}|${sec_detail}")
              done
              scored_server_data=("${updated_scored[@]}")
              IFS=$'\n' sorted_data=($(printf '%s\n' "${scored_server_data[@]}" | sort -t'|' -k1,1rn -k2,2n -k3,3n -k4,4n))
              unset IFS
            fi
            print_info "Sorted by quality."
          fi
          continue
          ;;
        d|D)
          if [[ "$current_sort_mode" != "detect" ]]; then
            current_sort_mode="detect"
            # Re-sort by detectability - clean first, then security score
            local updated_scored=()
            for entry in "${scored_server_data[@]}"; do
              local score det_sort owned_sort latency id name ip hostname country_code host_provider owned sec_detail
              IFS='|' read -r score det_sort owned_sort latency id name ip hostname country_code host_provider owned sec_detail <<< "$entry"
              det_sort=$(_detection_sort_value "$ip")
              updated_scored+=("${score}|${det_sort}|${owned_sort}|${latency}|${id}|${name}|${ip}|${hostname}|${country_code}|${host_provider}|${owned}|${sec_detail}")
            done
            scored_server_data=("${updated_scored[@]}")
            IFS=$'\n' sorted_data=($(printf '%s\n' "${scored_server_data[@]}" | sort -t'|' -k2,2n -k1,1rn -k3,3n -k4,4n))
            unset IFS
            # Check detection for newly visible servers
            local check_count=$((max_display + 50))
            [[ $check_count -gt ${#sorted_data[@]} ]] && check_count=${#sorted_data[@]}
            _check_server_detection "$check_count" "${sorted_data[@]}"
            print_info "Sorted by detectability."
          fi
          continue
          ;;
        s|S)
          if [[ "$current_sort_mode" != "speed" ]]; then
            current_sort_mode="speed"
            # Re-sort by speed - instant, field 4 is latency in new format
            IFS=$'\n' sorted_data=($(printf '%s\n' "${scored_server_data[@]}" | sort -t'|' -k4,4n))
            unset IFS
            # Check detection for newly visible servers (uses cache, only checks uncached)
            local check_count=$((max_display + 50))
            [[ $check_count -gt ${#sorted_data[@]} ]] && check_count=${#sorted_data[@]}
            _check_server_detection "$check_count" "${sorted_data[@]}"
            print_info "Sorted by speed (latency)."
          fi
          continue
          ;;
        *)
          # Number selection
          if [[ "$choice" =~ ^[0-9]+$ ]] && [[ "$choice" -ge 1 ]] && [[ "$choice" -le "${#display_data[@]}" ]]; then
            local idx=$((choice - 1))
            CONFIG[selected_region]="${region_ids[$idx]}"
            CONFIG[selected_ip]="${region_ips[$idx]}"
            CONFIG[selected_hostname]="${region_hostnames[$idx]}"
            print_ok "Selected: ${region_names[$idx]}"

            # Check for jurisdiction mismatch warning
            # Entry format: score|det_sort|owned_sort|latency|id|name|ip|hostname|country_code|host_provider|owned|sec_detail
            local selected_entry="${display_data[$idx]}"
            local _score _det_sort _owned_sort _lat _id _name _ip _host _country_code _host_provider _owned _sec_detail
            IFS='|' read -r _score _det_sort _owned_sort _lat _id _name _ip _host _country_code _host_provider _owned _sec_detail <<< "$selected_entry"

            if [[ "$_owned" == "false" && -n "$_host_provider" && "$_host_provider" != "unknown" ]]; then
              local mismatch
              mismatch=$(check_jurisdiction_mismatch "$_country_code" "$_host_provider" "$_owned")

              if [[ "$mismatch" == "5-EYES-HOSTED" ]]; then
                # Get display name from the entry
                local display_location="$_name"
                echo
                print_warn "JURISDICTION WARNING: This server claims '$display_location'"
                print_warn "but is hosted by $_host_provider (US-based, 5-Eyes jurisdiction)."
                print_warn "Traffic may route through US infrastructure despite the claimed location."
                echo
                if ! ask_yn "Continue with this selection?" "n"; then
                  print_info "Server selection cancelled. Returning to list."
                  continue
                fi
              fi
            fi
            break
          else
            print_error "Invalid selection. Enter a number 1-${#display_data[@]}, or m/q/s."
          fi
          ;;
      esac
    done

  echo
}

# ============================================================================
# PHASE 5: SUMMARY & CONNECT
# ============================================================================

phase_summary() {
  print_section "CONFIGURATION SUMMARY"

  echo "Provider:       ${C_BOLD}$(provider_name)${C_RESET}"
  echo

  echo "Security:"
  if [[ "${CONFIG[killswitch]}" == "true" ]]; then
    echo "  Kill switch:    ${C_GREEN}ENABLED${C_RESET} (LAN: ${CONFIG[killswitch_lan]})"
  else
    echo "  Kill switch:    ${C_RED}DISABLED${C_RESET}"
  fi

  if [[ "${CONFIG[ipv6_disabled]}" == "true" ]]; then
    echo "  IPv6:           ${C_GREEN}Disabled (interface + firewall)${C_RESET}"
  else
    echo "  IPv6:           ${C_YELLOW}Enabled (may leak)${C_RESET}"
  fi

  if [[ "${CONFIG[use_provider_dns]}" == "true" ]]; then
    local dns_server
    dns_server=$(provider_get_dns | head -1)
    echo "  DNS:            $(provider_name) ($dns_server)"
  else
    echo "  DNS:            System default"
  fi

  echo
  echo "Connection:"
  echo "  Protocol:       WireGuard"

  if [[ "${CONFIG[dip_enabled]}" == "true" ]]; then
    echo "  Server:         DIP (${CONFIG[selected_ip]})"
  else
    echo "  Server:         ${CONFIG[selected_region]} (${CONFIG[selected_ip]})"
  fi

  if [[ "${CONFIG[port_forward]}" == "true" ]]; then
    echo "  Port forward:   Yes"
  else
    echo "  Port forward:   No"
  fi

  echo
  echo "Press Enter to save configuration, or Ctrl+C to abort..."
  if ! read -r; then
    echo -e "\n\nCancelled."
    exit 130
  fi

  save_config
  print_ok "Configuration saved to $CONFIG_FILE"
  echo
  echo "To connect, run:"
  echo "  ${C_GREEN}sudo velum-connect${C_RESET}"
  echo
}

# ============================================================================
# SUBCOMMANDS
# ============================================================================

# Lint subcommand: validate config file
cmd_lint() {
  echo
  echo "${C_BOLD}velum-vpn Config Lint${C_RESET}"
  echo "====================="
  echo
  echo "Checking: $CONFIG_FILE"
  echo

  if [[ ! -f "$CONFIG_FILE" ]]; then
    print_error "Config file not found: $CONFIG_FILE"
    echo "Run 'velum config' to create a configuration."
    exit 1
  fi

  # Run lint mode (strict + known-keys-only, collects all errors)
  local result
  safe_load_config "$CONFIG_FILE" --lint
  result=$?

  # Exit codes: 0 = OK, 1 = errors, 2 = warnings
  exit $result
}

# Show usage
show_usage() {
  cat << 'EOF'
Usage: velum config [subcommand]

Subcommands:
  (none)    Run interactive configuration wizard
  lint      Validate existing configuration file

Examples:
  velum config         # Interactive wizard
  velum config lint    # Validate config file
EOF
}

# ============================================================================
# MAIN
# ============================================================================

main() {
  # Handle subcommands
  case "${1:-}" in
    lint)
      cmd_lint
      ;;
    -h|--help)
      show_usage
      exit 0
      ;;
    "")
      # No subcommand - run interactive wizard
      ;;
    *)
      print_error "Unknown subcommand: $1"
      show_usage
      exit 1
      ;;
  esac

  echo
  echo "${C_BOLD}velum-vpn Configuration${C_RESET}"
  echo "========================"
  echo

  # Migrate from legacy location if needed
  migrate_legacy_config

  # Check for and offer to clean up plaintext credentials (security)
  migrate_plaintext_credentials

  # Migrate tokens from disk to tmpfs if needed
  migrate_tokens_to_runtime

  # Check requirements
  check_os_requirements || exit 1

  # Check root for operations that need it
  if [[ "${CONFIG[killswitch]}" == "true" ]] || [[ "${CONFIG[ipv6_disabled]}" == "true" ]]; then
    if ! is_root; then
      print_warn "Note: Kill switch and IPv6 changes require root privileges."
      print_warn "You will be prompted for sudo password during connection."
    fi
  fi

  # Load existing config
  load_config

  # Check for deprecated external credential source and clear it
  if [[ "${CONFIG[credential_source]:-}" == "command" ]]; then
    credential_check_deprecated_source "${CONFIG[credential_source]}"
    echo
    print_info "Your credential source will be reconfigured during setup."
    CONFIG[credential_source]=""
    CONFIG[credential_command]=""
    echo
  fi

  # Run phases
  phase_provider
  phase_authentication
  phase_security
  phase_features
  phase_server
  phase_summary
}

# Run main
main "$@"
